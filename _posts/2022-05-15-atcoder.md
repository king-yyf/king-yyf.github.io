---
layout: post
title: codeforces/atcoder 选题
date: 2022-05-15
tags: 算法专题  
---


===

Index
---
<!-- TOC -->

- [codeforces](#codeforces)
  - [二进制字符串的最小代价](#二进制字符串的最小代价)
  - [最长区间](#最长区间)
  - [只剩一个星号的最小步数](#只剩一个星号的最小步数)
- [atcoder](#atcoder)
  - [饲喂所有动物的最小代价](#饲喂所有动物的最小代价)
  - [前缀集合是否相等](#前缀集合是否相等)

   
<!-- /TOC -->

## codeforces

### 二进制字符串的最小代价

[ecr128c div2](https://codeforces.com/contest/1680/problem/C)

题目：字符串s只包含字符 '0'和'1'，你可以从s的开始和结束删除任意数目的字符(包括0个或者全部)，删除后的字符串代价是下面两个值的最大值

+ 剩余字符串中0的数目
+ 删掉字符串中1的数目

求删除后字符串s的最小代价。

+ 1 <= s.length <= 2e5

**方法1:二分**

设总共有m个1，其出现位置分别在p[0],,,p[m-1], 则答案不超过m，对答案进行二分，设当前检测的答案为md,则我们最多能删除md个1，且当我们删除md个1时，能留下最少的0，因为从两端删除1不回增加剩下的0的数目。依次枚举，前面删除i个1，后面删除md-i个1时，中间留下的0是否小于等于md，判断md答案成不成立即可。

```c++
int minStringCost(string& s) {
    int n = s.size();
    vector<int> s1(n + 1), p;
    for (int i = 0; i < n; ++i) {
        s1[i + 1] = s1[i] + (s[i] == '0');
        if (s[i] == '1') p.push_back(i);
    }
    int m = p.size(), l = 0, r = m, ans = m;
    while (l < r) {
        int md = (l + r) / 2;
        bool ok = 0;
        for (int i = 0; i <= md; ++i) {
            int l1 = p[i], r1 = p[m - 1 - md + i];
            if (s1[r1 + 1] - s1[l1] <= md) {
                ok = 1;
            } 
        }
        if (ok) r = md;
        else l = md + 1;
    }
    return l;
}
```

**方法2：滑动窗口**

```c++
int minStringCost1(string& s) {
    int n = s.size(), x = 0, y = 0, ans = n;
    for (int i = 0; i < n; ++i) {
        if (s[i] == '0') x++;
        else y++;
    }
    int x1 = 0, y1 = y, j = 0;
    for (int i = 0; i < n; ++i) {
        while (j < n && x1 < y1) {
            if (s[j] == '0') x1++;
            else y1--;
            j++;
        }
        ans = min(ans, max(x1, y1));
        if (s[i] == '0') x1--;
        else y1++;
    }
    return ans;
}
```

**方法3:动态规划**

```c++
int minStringCost(string& s) {
    int n = s.size();
    vector<int> p(n + 1);
    for (int i = 0; i < n; ++i) {
        p[i + 1] = p[i] + (s[i] == '1');
    }
    if (p[n] == n || p[n] == 0) return 0;
    int res = min(p[n], n - p[n]);
    for (int i = 1; i <= n; ++i) {
        if (i >= p[n]) res = min(res, (i - p[i]) - (i - p[n] - p[i - p[n]]));
        else res = min(res, p[n] - p[i]);
    }
    return res;
}
```

### 最长区间

[cr790F div4](https://codeforces.com/contest/1676/problem/F)

题意：数组a，长度为n，给定k，找出任意两个l,r,满足

+ 对任意 l <= x <= r, x 在数组中至少出现k次。
+ r - l 尽可能大
+ 1 <= n <= 2e5, 1 <= k <= n, 1 <= ai <= 1e9

```c++
vector<int> maxRange(vector<int>& a, int k) {
    int n = a.size();
    map<int, int> mp;
    for(auto& x : a) mp[x]++;
    mp[INT_MAX] = 0;
    int ansl = -1, ansr = -2, l = -1, r = -2;
    for (auto &[x, y] : mp) {
        if (y < k || x != r + 1) {
            if (r - l >= ansr - ansl) {
                ansl = l, ansr = r;
            }
            if (y >= k) l = r = x;
        } else r = x;
    }
    if (ansl > 0) return {ansl, ansr};
    return {};
}
```

### 只剩一个星号的最小步数

[ecr128E, div2](https://codeforces.com/contest/1680/problem/E)

题意：有一个`2*n`的方格, 包括 星号 `'*'`和空白 `.`，保证至少有1个星号。

每一步星号可以移动到相邻的格子，如果移动后的新格子是`*`，则该格子的`*`被消灭，`*`不能走出方格。

求使得方格中有且仅有一个`*`的最少移动步数。

+ 1 <= n <= 2e5

**提示**

+ 最前面两列都是空白的和最后面两列都是空白的对答案没有贡献，可以删去。
+ 假设最后剩的`*`在第j列，那么小于j列的`*`只会往右走，大于j列的`*`只会往左走。
+ 最优解中，当前列只会保留一个`*`，因为如果有两个`*`，那么消灭掉一个`*`，只留一个`*`向右走会更优。

dp[i][0]: 最后处理的第i列，且`*`在第0行。
dp[i][0]: 最后处理的第i列，且`*`在第1行。

答案为 `min(dp[n - 1][0], dp[n - 1][1])`

```c++
int minMoveCost(vector<string>& s) {
    for (int i = 0; i < 2; ++i) {
        while (s[0].back() == '.' && s[1].back() == '.') {
            s[0].pop_back();s[1].pop_back();
        }
        reverse(s[0].begin(), s[0].end());
        reverse(s[1].begin(), s[1].end());
    }
    int n = s[0].size();
    vector<vector<int>> dp(n, vector<int>(2, 1e9));
    dp[0][0] = (s[1][0] == '*');
    dp[0][1] = (s[0][0] == '*');
    for (int i = 0; i + 1 < n; ++i) {
        dp[i + 1][0] = min(dp[i + 1][0], dp[i][0] + 1 + (s[1][i + 1] == '*'));
        dp[i + 1][0] = min(dp[i + 1][0], dp[i][1] + 2);
        dp[i + 1][1] = min(dp[i + 1][1], dp[i][1] + 1 + (s[0][i + 1] == '*'));
        dp[i + 1][1] = min(dp[i + 1][1], dp[i][0] + 2);
    }
    return min(dp[n - 1][0], dp[n - 1][1]);
}
```

## atcoder

### 饲喂所有动物的最小代价

[abc251 E](https://atcoder.jp/contests/abc251/tasks/abc251_e)

有n个动物，编号1到n。有n种喂动物组合：

+ 使用 a1 元 可以喂 动物1和动物2
+ 使用 a2 元 可以喂 动物2和动物3
+ ...
+ 使用 an 元 可以喂 动物n和动物1

求所有动物都得到饲喂所需要的最小代价。

+ 2 <= n <= 2e5
+ 1 <= ai <= 1e9

**分析**

+ 考虑第n个，可以使用an喂，也可以使用a1喂。
+ 如果使用an喂，则 a1可选，可不选
+ 如果不使用an喂，则 a1必选，a2可选可不选。
+ s1[i] 表示前i个，且选第i个的最小代价，s2[i]表示前i个，且不选第i个的最小代价
+ 选an时，s1[0] = a[0], s2[0] = 0;
+ 不选an，选a1时，s1[1] = a[1], s2[1] = 0;

```c++
long long minCost(vector<int> &a) {
    vector<long long> s1(n), s2(n);
    long long ans = 1e18;
    s1[0] = a[0], s2[0] = 0; // 选第n个，则第1个可以选或不选
    for (int i = 1; i < n - 1; ++i) {
        s1[i] = min(s2[i - 1], s1[i - 1]) + a[i];
        s2[i] = s1[i - 1];
    }
    ans = min(s1[n - 2], s2[n - 2]) + a[n - 1];
    s1[1] = a[1], s2[1] = 0;
    for (int i = 2; i < n; ++i) {
        s1[i] = min(s2[i - 1], s1[i - 1]) + a[i];
        s2[i] = s1[i - 1];
    }
    ans = min(ans, min(s1[n - 1], s2[n - 1]) + a[0]);
    return ans;
}
```

### 前缀集合是否相等

[abc250 E](https://atcoder.jp/contests/abc250/tasks/abc250_e)

有两个长度为n的数组a和b，有q个询问，第i个询问给出两个数x，y，判断a的前x个数与b的前y个数构成的集合是否相等。

+ 1 <= n, q <= 2e5
+ 1 <= ai, bi <= 1e9
+ 1 <= xi, yi <= n

**方法1:哈希**

```c++
using ull = unsigned long long;
vector<int> prefixSetEqual(vector<int>& a, vector<int>& b, vector<vector<int>>& q) {
    int n = a.size(), m = q.size();
    vector<int> ans(m);
    mt19937_64 rng(random_device{}()); 
    set<int> st1, st2;
    map<int, ull> mp;
    for (auto &x: a) if (!mp.count(x)) mp[x] = rng();
    for (auto &x: b) if (!mp.count(x)) mp[x] = rng();
    vector<ull> s1(n+1), s2(n+1);
    for(int i = 0; i < n; ++i) {
        s1[i + 1] = s1[i];
        if (!st1.count(a[i])) s1[i + 1] += mp[a[i]];
        st1.insert(a[i]);
    }
    for(int i = 0; i < n; ++i) {
        s2[i + 1] = s2[i];
        if (!st2.count(b[i])) s2[i + 1] += mp[b[i]];
        st2.insert(b[i]);
    }
    for (int i = 0; i < m; ++i) {
        if (s1[q[i][0] + 1] == s2[q[i][1] + 1]) ans[i] = 1;
    }
    return ans;
}
```

**方法2**

+ 对于 x = 1, 2, ... n, 使得查询 (x,y) 为 `true` 的 y 如果存在，一定是一个特定区间[l, r]。
+ l[x], r[x] 表示 使得(x,y)为true，的y的左边界和右边界。使用两个set维护，当前前缀a[i]和b[j]集合是否相等。
+ 对于查询(x,y)，如果y在[l[x],r[x]]中，则为true，否则为false。


```c++
vector<int> prefixSetEqual(vector<int>& a, vector<int>& b, vector<vector<int>>& q) {
    int n = a.size(), m = q.size();
    vector<int> l(n, n), r(n, -1), ans(m);
    set<int> s1, s2;
    for (int i = 0, j = 0; i < n; ++i) {
        if (s1.count(a[i])) {
            l[i] = l[i - 1], r[i] = r[i - 1];
            continue;
        }
        s1.insert(a[i]);
        while (j < n && s1.size() != s2.size()) {
            if (!s1.count(b[j])) break;
            s2.insert(b[j++]);
        }
        if(s1.size() == s2.size()) {
            l[i] = j - 1;
            while (j < n && s2.count(b[j])) j++;
            r[i] = j - 1;
        }

    }
    for (int i = 0; i < m; ++i) {
        if (q[i][1] >= l[q[i][0]] && q[i][1] <= r[q[i][0]]) ans[i] = 1;
    }
    return ans;
}
```