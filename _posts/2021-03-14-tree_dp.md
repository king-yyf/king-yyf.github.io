---
layout: post
title: 树形DP例题
date: 2021-03-14
tags: 算法竞赛   
---


===

Index
---
<!-- TOC -->

- [没有上司的舞会](#没有上司的舞会)
- [选课](#选课)
- [树的重心](#树的重心)
- [树的最长路径](#树的最长路径)
- [树的中心](#树的中心)

<!-- /TOC -->


### 没有上司的舞会


[acwing 285](https://www.acwing.com/problem/content/287/)

Ural 大学有 N 名职员，编号为 1∼N。
他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。
每个职员有一个快乐指数，用整数 Hi 给出，其中    `1≤i≤N`。
现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

**输入格式**
第一行一个整数 N。

接下来 N 行，第 i 行表示 i 号职员的快乐指数 Hi。

接下来 N−1 行，每行输入一对整数 L,K，表示 K 是 L 的直接上司。

**输出格式**
输出最大的快乐指数。

**数据范围**
1 ≤ N ≤ 6000,
−128 ≤ Hi ≤ 127

**输入样例**
```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

**输出样例**
```
5
```

**题解：**

考虑一颗以u为根结点的子树，这颗子树的快乐指数应该是u的函数，并且分两种情况，**选u和不选u。**

**状态表示：**  
```
f[u][1]: 以u为根结点的子树并且包括u的总快乐指数
f[u][0]: 以u为根结点的子树并且不包括u的总快乐指数
```

**状态计算**
```
记点u的子节点是s1,s2...sk。
1. 选u， f[u][1] += f[s1][0] + f[s2][0] + ... + f[sk][0]
2. 不选u，f[u][0] += max(f[s1][1], f[s1][0]) + ... + max(f[sk][1], f[sk][0])
```

**代码**

```c++
#include<iostream>
#include<vector>
using namespace std;

const int N = 6000 + 10;

int n, u, v;
vector<int> G[N];
int f[N][2], h[N], fa[N];

void dfs(int u) {
    f[u][1] = h[u];
    for (auto e : G[u]) {
        dfs(e);
        f[u][0] += max(f[e][0], f[e][1]);
        f[u][1] += f[e][0];
    }
}

int main(){
    cin >> n; 
    for (int i = 1; i <= n; ++i) cin >> h[i];
    
    for (int i = 1; i < n; ++i) {
        cin >> u >> v;
        fa[u] = 1;
        G[v].push_back(u);
    }
    
    int root = 1;
    while(fa[root]) root++;
    dfs(root);
    cout << max(f[root][0], f[root][1]);
    return 0;
}
```

### 选课

[acwing 286](https://www.acwing.com/problem/content/288/)

**题意**

>* 一个学校开设了N门课，每个学生可选课程的数量M是给定的。
>* 学生选了M门课并考完就能拿到相应的学分。
>* 有的课可以直接选，有的课得修完先修课才能选。
>* 每门课直接选修课最多只有一门，两门课可能存在相同的先修课。
>* 求选课方案使学分最高。
>* 数据范围：`N≤300`。

**输入格式**
第一行包含两个整数n和m，1 <= n <= 300, 1 <= m <= n。
接下来 n 行每行代表一门课，课号依次为 1，2，…，n。
每行有两个数，第一个数为这门课选修课的课号（若不存在选修课则该项为0），第二个数为这门课的学分。

学分是不超过10的正整数

**输出格式**
输出一个整数，表示总学分数

**输入样例**
```
7 4
2 2
0 1
0 4
2 1
7 1
7 6
2 2
```

**输出样例**
```
13
```

**题解：**
>*每门课都有先修课，那么可以想成一门课是他的先修课的儿子。
>*那一门课和他的后选课就可以构成一棵树。
>*然而有可能有很多课没有先修课，也就是由很多个根节点，那么这就是个森林。
>*为了方便起见，设立0号节点为虚节点，作为没有先修课的课的先修课。
>*设计转移方程f(x,t)f(x,t)表示在xx及其子树中选tt门课能得到的最大学分。
>*那么有f(x,t)=max(f(y,c))+sorcef(x,t)=max(f(y,c))+sorce。
>*这其实就是一个树上分组背包的模型。
>*稍作一下解释吧， 假设说11号节点是22号节点的父节点，那么对于22节点及其子树构成一组物品，对于22号节点有许多种体积的子背包，对于11号节点而言，他只能从这许多种体积的子背包中选一个加入自己的背包中，而11号节点有可能有许多个子节点，所以其实是树上分组背包。
>*因为我们必须要选根节点，所以我们m++，并从0号节点开始dfs。

```
作者：zhaoxiaoyun
链接：https://www.acwing.com/blog/content/1568/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

代码
```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 300 + 10;
int n, m, h[maxn];
int f[maxn][maxn];
int head[maxn], ver[maxn<<1], nex[maxn<<1], tot;
inline void add_edge(int x, int y){
    ver[++tot] = y; nex[tot] = head[x]; head[x] = tot;
}

void dfs(int x) {
    for(int i = head[x]; i; i = nex[i]) {
        int y = ver[i]; dfs(y);
        for(int j = m-1; j >= 0; j--) {
            //选择一个子节点体积为k的子背包
            for(int k = 0; k <= j; k++)
                f[x][j] = max(f[x][j], f[x][j-k] +f[y][k]);
        }
    }
    //本身要选修x
    if(x != 0)
    for(int i = m; i > 0; i--)
        f[x][i] = f[x][i-1] + h[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1, x, y; i <= n-1; i++) {
        scanf("%d%d", &x, &y);
        add_edge(x, i); h[i] = y;
    } dfs(0);
    cout << f[0][m] << endl;
    return 0;
}
```

### 树的重心

**题目**

给定一颗树，树中包含n个节点（编号1-n），和n-1条无向边。
请你找出树的重心，并输出将重心删除后，剩余各个联通块中点数的最大值。
**重心定义**：重心是指树中一个节点，如果将这个点删除后，剩余各个连通块中点数的最大值最小。

**输入格式**
第一行包含整数n,表示树的节点数。1<=n<=1e5
接下来n-1行，每行包含两个整数a和b，表示点a和点b之间有一条边。

**输出格式**
输出一个整数m，表示将重心删除后，剩余各个连通块中点数的最大值。

**输入样例**
```
9
1 4
1 2
2 6
2 5
6 3
6 7
7 9
7 8
```

**输出样例**
```
4
```

**题解**
>* 任取一点u，若以u为重心，则分为两类：一类是 **u的子树**，一类是 **u上面的部分**
>* 需要算出u的最大子树的节点数和u上面部分的节点数，然后二者取最大值即可。

```
size: 记录u的最大子树的节点数
sum: 记录以u为根的子树的节点数
n-sum：u上面的部分的节点数
ans = max(size, n - sum)
vis[u]:标记u这个节点是否被搜过
```

**代码**
```c++
int dfs(int u) {
    vis[u] = true;
    int size = 0;
    int sum = 1;
    for (auto& e : G[u]) {
        if(vis[e]) continue;
        int s = dfs(e);  //s是以e为根的子树的节点数
        size = max(size, s); //记录u的最大子树的节点数
        sum += s;  //累加u的各个子树的节点数
    }
    ans = min(ans, max(size, n - sum));
    return sum;
}
```

### 树的最长路径

**题目**

给定一颗树，树中包含n个节点（编号1-n），和n-1条无向边，每条边都有一个权值。
请你找出树中最长的一条路径。
换句话说，要找到一条路径，使得路径两端点的距离最远。
“注意”：路径中可能只包含一个点。


**输入格式**
第一行包含整数n,表示树的节点数。1<=n<=1e4
接下来n-1行，每行包含三个整数a，b, c，表示点a和点b之间有一条权值为c的边。
-1e5 <= c <= 1e5

**输出格式**
输出一个整数，表示树的最长路径的长度。

**输入样例**
```
6
5 1 6
1 4 5
6 3 9
2 6 8
6 1 7
```

**输出样例**
```
22
```

**题解**
>* 任取一点u，从u点向下搜，返回时收集边的权值，记录两条路径
>* d1: 记录从u点往下走的最长路径的长度
>* d2: 记录从u点往下走次长路径的长度
>* d[u] = d1 + d2, 表示悬挂在u点上的最长路径长度/
>* 因为u时任取一点，所以遍历完所有点，会得到一组d[i]，答案 ans = max(d[i])
>* 不需要开设d数组，每遍历完一个点，及时更新全局变量ans即可
>* ans = max(ans, d1 + d2)

**代码**
```c++
int dfs)(int u) {
    vis[u] = true;
    int d1 = 0, d2 = 0;
    for (auto e : G[u]) {
        if(vis[e]) continue;
        int d = dfs(e.to) + e.cost;
        if (d >= d1)  d2 = d1, d1 = d;
        else if (d > d2) d2 = d;
    }
    ans = max(ans, d1 + d2);
    return d1;
}
```

### 树的中心

**题目**

给定一颗树，树中包含n个节点（编号1-n），和n-1条无向边，每条边都有一个权值。
请你找出树中找到一个点，使得该点到树中其它点的最远距离最近，该点称为树的中心。


**输入格式**
第一行包含整数n,表示树的节点数。1<=n<=1e4
接下来n-1行，每行包含三个整数a，b, c，表示点a和点b之间有一条权值为c的边。
-1e5 <= c <= 1e5

**输出格式**
输出一个整数，表示树的中心到树中其它点的最远距离

**输入样例**
```
5
2 1 1
3 2 1
4 3 1 
5 1 1
```

**输出样例**
```
2
```

**题解**
>* 点u到其它点的最远距离，可以分为两类：
>* 一类是从u点向下走最远距离，用d1[u]表示
>* 一类是从u点向上走的最远距离，用up[u]表示
>* 从u到其它点的最远距离；max(d1[u], up[u])
>* 从中心到其它点的最远距离： min(max(d1[i], up[i]))

>* 从u点向下走的最远距离d1[u]
>* 从下而上递推，由子节点信息更新父节点信息
>* 从u点向下走的最大长度， d1[u] = d1[j] + w[i]
>* 从u点向下走的次大长度 d2[u] = d2[j] + w[i]
>* 也就是说，在返回时实现，即在dfs后实现

>* 从u点向上走的最远距离up[u]
>* 从上而下递推，由父节点信息更新子节点信息
>* 如果j在从u点向下走的最长路径上 up[j] = w[i]+max(up[u],d2[u])
>* 如果j不在从u点向下走的最长路径上 up[j] = w[i]+max(up[u],d1[u])
>* 也就是说，在下行时实现，即在dfs之前实现


**代码**
```c++
int dfs_d)(int u, int fa) {
    d1[u] = 0, d2[u] = 0; //u向下走的最大长度和次大长度
    for (auto e : G[u]) {
        if (e.to == fa) continue;
        int d = dfs_d(e.to, u) + e.cost; //p1[u]记录从u点向下走的最长路径是从哪个点下去的
        if (d >= d1[u]) d2[u] = d1[u], d1[u] = d, p1[u] = e.to;
        else if (d > d2[u]) d2[u] = d;
    }
    return d1[u];
}

void dfs_u)(int u, int fa) {
    for (auto e : G[u]) {
        if (e.to == fa) continue;
        if (p1[u] == e.to) 
            up[e.to] = max(up[u], d2[u]) + e.cost;
        else up[e.to] = max(up[u], d1[u]) + e.cost;
        dfs_u(e.ot, u);
    }
}
```



