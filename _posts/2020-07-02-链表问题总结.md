---
layout: post
title: 链表问题总结
date: 2020-07-02
tags: leetcode    
---

链表问题是c/c++技术岗面试过程中的重点问题，通过对各种链表操作的考察，能够反映出面试者对编程语言掌握的熟练程度，对链表数据结构和指针、地址等概念的理解。


### 链表定义

采用leetcode中的链表通用定义。    

```c++
struct ListNode{
    int val;
    ListNode * next;
    ListNode(int v):val(v),next(nullptr){}
};
```

### 1.在O(1)时间内删除链表节点

**题目描述：** 给定链表中间的某个节点指针，在O(1)时间内删除该节点。假定你只能访问该节点。  
**分析：** 在这个问题里，由于访问不到该节点的前一个节点，所以 **这题对尾节点是无解的** 。要删除当前节点，直接将其next节点的值复制到当前节点，然后删除后继节点。   

实现代码：
```c++
bool deleteListNode(ListNode * cur){
    if(cur == nullptr || cur->next == nullptr)
        return false;
    ListNode * pNext = cur->next;
    cur->val = pNext->val;
    cur->next = pNext->next;
    delete pNext;
    return true;
}
```

### 2.单链表反转

**题目描述：** 给定一个单向链表的头节点，将链表反转，并返回头节点。  

**分析：** 链表反转类问题一般需要用到三个临时指针，pre，cur,next，使用三个指针对链表进行一次循环即可反转，同时为了便于操作，一般会设一个dummyHead节点，其next指针指向head节点。  
实现代码:  
```c++
ListNode* reverseList(ListNode* head){
    if(head == nullptr || head->next == nullptr) return head;

    ListNode* pre = nullptr, *p = head, *next = p->next;
    while(p){
        next = p->next;
        p->next = pre;
        pre = p;
        p = next;
    }
    return pre;
}
```

### 3.求链表的倒数第k个节点

**题目描述：** 输入一个单向链表，输出该链表中倒数第k个节点。  
**分析：** 快慢指针法，设置两个指针slow,fast，初始时都指向head，先让fast走k步，然后slow,fast同时走，当fast走到链表末尾时，slow就是倒数第k个节点。  

```c++
ListNode* findkthNode(ListNode *head, int k){
    if(k < 0 || head == nullptr) return nullptr;
    ListNode* slow, *fast;
    slow = fast = head;
    int i = k;
    while(i > 0 && fast){
        fast = fast->next;
        i--;
    }
    if(i > 0) return nullptr;
    while(fast){
        slow = slow->next;
        fast = fast->next;
    } 
    return slow;
}
```


### 4.求链表的中间节点

**题目描述：** 求链表的中间节点，，如果链表长度为偶数，返回中间两个节点的任意一个，若为奇数，返回中间节点。  
**分析：** 快慢指针法，fast每次移动两部，slow每次移动一步。

```c++
ListNode* findMiddleNode(Node* head){
    if(head == nullptr) return nullptr;

    ListNode* slow, *fast;
    slow = fast = head;
    while(fast != nullptr && fast->next != nullptr){
        fast = fast->next->next;
        slow = slow->next;
    }
    return slow;
}
```

### 5.判断单链表是否有环

**题目描述：** 输入一个单向链表，判断链表是否有环。
**分析：** 快慢指针，如果存在环，那么两个指针必会在环中相遇。

```c++
bool hasCircle(ListNode *head){
    Node *slow, *fast;
    slow = fast = head;
    while(fast != nullptr && fast->next != nullptr){
        fast = fast->next->next;
        slow = slow->next;
        if(fast == slow){
            return true;
        }
    }
    return false;
}
```

### 6.找到环的入口

**题目描述：** 输入一个单向链表，判断链表是否有环，如果存在环，找到环的入口。  
**分析:** 快慢指针,如果快慢指针相遇，则有环，这是将其任意一个设为head，按相同速度走，则其再次相遇时，即为环的入口。  

```c++
ListNode * detectCycle(ListNode * head){
    ListNode *fast=head, *slow = head;
    while(fast && fast->next){
        fast = fast->next->next;
        slow = slow->next;
        if(fast == slow){
            fast = head;
            while(fast != slow){
                fast = fast->next;
                slow = slow->next;
            }
            return fast;
        }
    }
    return nullptr;
}
```

### 7.判断两个链表是否相交

**题目描述：** 给出两个单链表的头指针，判断两个链表是否相交，假设两个链表均不带环。
**分析:** 如过两个链表相交，则从交点到链表末尾都是公共的，所以只需要判断两个链表的末尾节点是否相同。
时间复杂度O(len1+len2)，空间复杂度O(1)。

```c++
bool isIntersect(ListNode* h1, ListNode* h2){
    if(h1 == nullptr || h2 == nullptr) return false;
    while(h1->next) 
        h1 = h1->next;
    while(h2->next)
        h2 = h2->next;
    return h1 == h2;
}
```

### 8.链表有环，如何判断相交

**题目描述:** 对第7题，如果链表是有环的，该怎么做？  
**分析：** 如果两个链表有环且相交，则两个链表有共同一个环，因此可以一个链表上两个指针相遇的节点，在不在另一个链表上。

```c++
bool isIntersectWithCircle(ListNode* h1, ListNode* h2){
    ListNode * p1 = detectCycle(h1); *p2 = detectCycle(h2);
    if(!p1 || !p2) return false;

    ListNode * tmp = p2->next;
    while(tmp != p2){
        if(tmp == p1)
            return true;
        tmp = tmp->next;
    }
    return false;
}
```

### 9.两个链表相交的第一个公共节点

**题目描述:** 如果两个无环单链表相交，求出它们第一个公共节点。    
**分析：** 计算两个链表长度l1和l2，将较长链表像后移动l2-l1个节点，然后同时移动两个指针，直到相等。  

```c++
int listLength(ListNode* head){
    int len = 0;
    while(head){
        len++;
        head = head->next;
    }
    return len;
}
ListNode* findFirstIntersectNode(ListNode* h1, ListNode* h2){
    int len1 = listLength(h1), len2 = listLength(l2);
    if(len1 > len2){
        for(int i = 0; i < len1-len2; i++)
            h1 = h1->next;
    }else{
        for(int i = 0; i < len2-len1; i++)
            h2 = h2->next;
    }
    while(h1 != nullptr){
        if(h1 == h2)
            return h1;
        h1 = h1->next;
        h2 = h2->next;
    }
    return nullptr;
}
```

### 10.K个一组翻转链表

**题目描述：** 给你一个链表，每k个节点一组进行翻转，k是不大于链表长度的正整数，如果节点总数不是k的整数倍，那么请将剩余的节点保持原有顺序。

```c++
    ListNode* reverse(ListNode * prev, ListNode *begin, ListNode * end){
        ListNode * end_next = end->next, *p = begin, *cur, *next;
        for(p = begin, cur = p->next, next=cur->next; cur!= end_next; p=cur, cur=next, next=next?next->next:NULL){
            cur->next = p;
        }
        begin->next = end_next;
        prev->next = end;
        return begin;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == NULL || head->next == NULL || k < 2) return head;
        ListNode * dummy = new ListNode(-1);
        dummy->next = head;

        ListNode *prev = dummy, *end = head;
        for(prev = dummy,end=head; end; end = prev->next){
            for(int i = 1; i < k && end; i++){
                end = end->next;
            }
            if(end == NULL) break;
            prev = reverse(prev, prev->next, end);
        }
        return dummy->next;
    }
```

### 11.反转从位置 m 到 n 的链表。

**题目描述：** 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。1 ≤ m ≤ n ≤ 链表长度。
示例：`输入：1->2->3->4->5->NULL, m = 2, n = 4`
     `输出: 1->4->3->2->5->NULL`

```c++
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if(!head || !head->next || n == m) return head;

        ListNode * dummyHead = new ListNode(-1);
        dummyHead->next = head;
        ListNode* p1 = head, *p2 = head, *pre = dummyHead;
        for(int i = 1; i < m; i++){
            pre = p1;
            p1 = p1->next;
        } 
        for(int i = 1; i < n; i++){
            p2 = p2->next;
        }
        ListNode * cur=p1->next;
        ListNode * pnext = NULL;
        ListNode * p2_next = p2->next;
        ListNode * p1_pre = pre;
        pre = p1;
        while(cur != p2_next){
            pnext = cur->next;
            cur->next = pre;
            pre = cur;
            cur = pnext;
        }
        p1_pre->next = p2;
        p1->next = p2_next;
        return dummyHead->next;
    }
```

### 12.删除排序链表中重复元素

**题目描述：** 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

**分析：** 双指针法，将相同的第一个节点的next指针指向下一个不同的节点或者NULL

```c++
  }ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return head;
        ListNode* p = head;
        ListNode* q = head -> next;
        while(true){
            while(q && p -> val == q -> val) q = q -> next;
            p -> next = q;
            p = p -> next;
            if(!q) break;
            else q = q -> next;
        }
        return head;
    }
```

### 13.合并2个有序链表

**题目描述：** 将两个升序链表合并为一个新的 升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```c++
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(!l1) return l2;
        if(!l2) return l1;
        ListNode *head, *cur;
        if(l1 -> val < l2 -> val) head = l1, l1 = l1 -> next;
        else head = l2, l2 = l2 -> next;
        cur = head;
        while(l1 && l2){
            if(l1 -> val < l2 -> val) cur -> next = l1, l1 = l1 -> next;
            else cur -> next = l2, l2 = l2 -> next;
            cur = cur -> next;
        }
        if(l1) cur -> next = l1;
        if(l2) cur -> next = l2;
        return head;
    }
```

### 14.合并k个有序链表

**题目描述：** 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**分析：** 维护当前每个链表没有被合并的元素的最前面一个，k个链表就最多有 k个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。

**复杂度：** 时间复杂度：考虑优先队列中的元素不超过 k 个，那么插入和删除的时间代价为 O(log k)，这里最多有 kn 个点，对于每个点都被插入删除各一次，故总的时间代价即渐进时间复杂度为O(kn×logk)。空间复杂度：这里用了优先队列，优先队列中的元素不超过 k个，故渐进空间复杂度为 O(k)。


```c++
    struct Status {
        int val;
        ListNode *ptr;
        bool operator < (const Status &rhs) const {
            return val > rhs.val;
        }
    };

    priority_queue <Status> q;

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for (auto node: lists) {
            if (node) q.push({node->val, node});
        }
        ListNode head, *tail = &head;
        while (!q.empty()) {
            auto f = q.top(); q.pop();
            tail->next = f.ptr; 
            tail = tail->next;
            if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});
        }
        return head.next;
    }

```

