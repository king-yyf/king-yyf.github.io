---
layout: post
title: leetcode中的图
date: 2020-09-04
tags: leetcode    
---




### 并查集

[leetcode 684 : 冗余连接](https://leetcode-cn.com/problems/redundant-connection/) 无向图
[leetcode 685 : 冗余连接II](https://leetcode-cn.com/problems/redundant-connection-ii/description/) 有向图

### 拓扑排序

1. [leetcode 207 : 课程表](https://leetcode-cn.com/problems/course-schedule/)

你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

```c++
    bool canFinish(int n, vector<vector<int>>& pres) {
        vector<vector<int>> G(n);
        vector<int> degree(n, 0), bfs;
        for (auto& e : pres) {
            G[e[1]].push_back(e[0]);
            degree[e[0]]++;
        }
        for (int i = 0; i < n; ++i) 
            if (!degree[i]) bfs.push_back(i);
        
        for (int i = 0; i < bfs.size(); ++i) 
            for (int j : G[bfs[i]]) {
                if (--degree[j] == 0) 
                    bfs.push_back(j);
            }
        return bfs.size() == n;
    }
```

2. [leetcode 210 : 课程表II](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

```c++
    vector<int> findOrder(int n, vector<vector<int>>& pres) {
        vector<int> G[n], degree(n, 0), ans;
        for (auto& e : pres) {
            G[e[1]].push_back(e[0]);
            degree[e[0]]++;
        } 
        queue<int> que;
        for (int i = 0; i < n; ++i) 
            if (!degree[i]) que.push(i);

        while(!que.empty()){
            int tmp = que.front();
            ans.push_back(tmp);
            que.pop();
            for(int x : G[tmp]){
                if(--degree[x] == 0) que.push(x);
            }
        }
        return ans.size() == n ? ans : vector<int>();
    }
```

### 克隆图

[leetcode 133](https://leetcode-cn.com/problems/clone-graph/)

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。
```
class Node {
    public int val;
    public List<Node> neighbors;
}
```


```c++
    map<Node*,Node*> mp;
    Node* cloneGraph(Node* node) {
        if(!node)   return nullptr;
        if(mp.count(node))  return mp[node];
        Node* c = new Node(node -> val);
        mp[node] = c;
        for(int i = 0; i < node -> neighbors.size(); ++ i){
            if(node -> neighbors[i])    
                c -> neighbors.push_back(cloneGraph(node -> neighbors[i]));
        }
        return c;
    }
```

### 判断二分图

给定一个无向图graph，当这个图为二分图时返回true。

如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。

graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。

```c++
    bool isBipartite(vector<vector<int>>& graph) {
        int N = graph.size();
        int color[N];
        memset(color, 0, sizeof(color));
        queue<int> que;
        for(int i = 0; i < N; i++){
            if(color[i]) continue;
            color[i] = 1;
            que.push(i);
            while(!que.empty()){
                int q = que.front();
                que.pop();
                for(int next : graph[q]){
                    if(color[next] == 0){
                        color[next] = -color[q];
                        que.push(next);
                    }
                    else if(color[next] == color[q]){
                        return false;
                    }
                }
            }
        }
        return true;
    }
```

dfs方法：
```c++
     bool dfs(const vector<vector<int>> &g, int i, int c, vector<int> &v) { 
        if (v[i] != -1) return v[i] == c;
        v[i] = c;
        for (int j : g[i]) if (!dfs(g, j, !c, v)) return false; 
        return true;
    }
    bool isBipartite(vector<vector<int>>& graph) {
        const int n = graph.size();
        vector<int> v(n, -1);                                                
        for (int i = 0; i < n; i++) if (v[i] == -1 && !dfs(graph, i, 0, v)) return false;
        return true;
    }
```

[leetcode 1129 : 颜色交替的最短路径](https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/)