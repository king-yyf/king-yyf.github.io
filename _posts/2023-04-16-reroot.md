---
layout: post
title: 换根dp模板
date: 2023-04-16
tags: 算法专题  
---


===

Index
---
<!-- TOC -->

- [模板](#模板)
  - [简介](#简介)
- [例题](#例题)
  - [EDPC-V Subtree](#dp_contest_subtree)
  - [Maximum White Subtree](#最多白色节点子树)
  - [树上边权加终点点权最长路径](#树上边权加终点点权最长路径)


   
<!-- /TOC -->


### 模板

```c++
template <class T,   // dp值的类型，如ll，int等。
        T(*op)(T, T), // 合并运算，需要满足交换律 op(dp[i], dp[j])
        T(*e)(),    // op 运算单位元，op(x, e()) = x
        T(*G)(T, int, int), // 根节点累积信息 G(dp[child], child, fa)
        class E,  // 边上 weight 的类型
        T(*F)(T, int, int, E)> // 子节点信息转移为父节点 F(dp[child], child, fa, weight(child, fa))
struct ReRooting : public vector<vector<pair<int, E>>> {
    using base_type = vector<vector<pair<int, E>>>;
    public:
        static constexpr int NIL = -1;
        using base_type::base_type;

        void add_edge(int u, int v, const E& w) {
            (*this)[u].emplace_back(v, w);
            (*this)[v].emplace_back(u, w);
        }

        const vector<T>& get(int root = 0) {
            const int n = this->size();
            dp.resize(n), to_par.resize(n);
            dfs_subtree(root, NIL);
            dfs(root, NIL, e());
            return dp;
        }

    private:
        vector<T> dp, to_par;

        void dfs_subtree(int u, int p) {
            dp[u] = e();
            for (auto [v, w] : (*this)[u]) {
                if (v == p) continue;
                dfs_subtree(v, u);
                dp[u] = op(dp[u], to_par[v] = F(G(dp[v], v, u), v, u, w));
            }
        }
        void dfs(int u, int p, T from_p) {
            dp[u] = G(dp[u], u, NIL);
            const int sz = (*this)[u].size();
            vector<T> cum_l { e() };
            cum_l.reserve(sz + 1);
            for (const auto& [v, _] : (*this)[u]) cum_l.push_back(op(cum_l.back(), v == p ? from_p : to_par[v]));
            T cum_r = e();
            for (int i = sz - 1; i >= 0; --i) {
                const auto& [v, w] = (*this)[u][i];
                if (v == p) {
                    cum_r = op(from_p, cum_r);
                } else {
                    T from_u = F(G(op(cum_l[i], cum_r), u, v), u, v, w);
                    dp[v] = op(dp[v], from_u);
                    dfs(v, u, from_u);
                    cum_r = op(to_par[v], cum_r);
                }
            }
        }
};

// dp[v]=g( op(f(dp[c1], v1),  f(dp[c2], v2) , ... f(dp[c2], v2)), v)
using S = int;
using E = nullptr_t;
S op(S x, S y) {
    return x * y;
}
S e() {
    return 0;
}
S G(S x, int u, int fa) {
    return x;
}
S F(S x, int u, int fa, E w) {
    return x + 1;
}
// ReRooting<S, op, e, G, E, F> g(n);
```

### 简介

考虑以顶点v为根时的树DP。

设 T 是某种数据类型构成的集合。 

dp[v] in T  dp[v] 表示以v为根的子树的某种数量/判定等。

此时，树DP的迁移

+ 两个变量的函数 f,g   T * N -> T 
+ 可交换的 merge T * T -> T
+ v 的子集和 ch(v)

使用 

`dp[v] = g(  merge(  f(dp[c1], v1),  f(dp[c2], v2) , ... f(dp[c2], v2) )  , v)`

如果转移能通过这种方式表示，就能够使用换根dp的模板, f 和 g 需要一个顶点编号作为其第二个参数，很多时候是用不到的，merge 必须满足可交换。

## 例题


### dp_contest_subtree

[atc dp_v_subtree](https://atcoder.jp/contests/dp/tasks/dp_v)

n 棵节点的树，编号1-n, 需要将每个节点染成黑色或白色，使得任意黑色节点可以仅经过黑的节点到达其他所有黑色节点。对于每个节点v，
假设v节点必须被染成黑色，求其他节点的染色方案数目，模m。

+ 1 <= n <= 1e5
+ 2 <= m <= 1e9

**分析**

dp[i] 表示以节点i为根的子树，在i节点必须染成黑色的情况下的方案数，则

`dp[i] = (dp[c1]+1)*(dp[c2]+1)*...(dp[ck]+1)` 其中每个子节点要么染成黑色，方案数为dp[ci],要么没有节点染成黑色，方案数为1.

则 

+ f(a, v) = a + 1
+ op(x, y) = x * y
+ g(a, v) = a

```c++
#include <bits/stdc++.h>
using namespace std;

// rerooting dp
// dynamic_mod 
using mint  = dynamic_mod<998244353>;
using S = mint;
using E = nullptr_t;
S op(S x, S y) {
    return x * y;
}
S e() {
    return 1;
}
S G(S x, int u, int fa) {
    return x;
}
S F(S x, int u, int fa, E w) {
    return x + 1;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    
    int n, m;
    cin >> n >> m;

    mint::set_mod(m);

    ReRooting<mint, op, e, G, E, F> g(n);
    for (int i = 0; i < n - 1; ++i) {
        int x, y;
        std::cin >> x >> y;
        --x, --y;
        g.add_edge(x, y, nullptr);
    }

    for (mint e : g.get()) {
        std::cout << e.val() << '\n';
    }
    return 0;
}
```

### 最多白色节点子树

[cf 1324F](https://codeforces.com/contest/1324/problem/F)

n 棵节点的树，编号1-n, 给定长度为n数组a，a[i]=1 表示节点i是白色，0为黑色，对于每个节点v，求：选择一个包含v节点的子树，该子树的白色节点数与黑色节点数的差最大。

+ 2 <= n <= 2e5
+ a[i] = 0 或 1

**分析**

dp[v]表示表示以v为根的子树，必须选择v时，白色节点数与黑色节点数的最大差。
则 `dp[v] = max(dp[c1],0)+max(dp[c2],0)+...+ max(dp[ck],0) + w[v]` a[v]=1时，w[v]=1, 否则为-1.

```c++
vector<int> a;
using S = int;
using E = nullptr_t;
S op(S x, S y) {
    return x + y;
}
S e() {
    return 0;
}
S G(S x, int u, int fa) {
    return x + a[u];
}
S F(S x, int u, int fa, E w) {
    return max(x, 0);
}
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    
    int n;
    cin >> n;
    a.resize(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        if (a[i] == 0) a[i] = -1;   
    }

    ReRooting<S, op, e, G, E, F> g(n);
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        u--, v--;
        g.add_edge(u, v, nullptr);
    }

    for (auto &p : g.get()) {
        cout << p << ' ';
    }

    cout << '\n';
    return 0;
}
```

### 树上边权加终点点权最长路径

[abc 222 f](https://atcoder.jp/contests/abc222/tasks/abc222_f)

输入 n(2≤n≤2e5) 和一棵树的 n-1 条边（节点编号从 1 开始），每条边输入两个端点和边权。
然后输入 n 个数 d，d[i] 表示点 i 的点权。

定义 f(x,y) = 从 x 到 y 的简单路径的边权之和，再加上 d[y]。
定义 g(x) = max{f(x,i)}，这里 i 取遍 1~n 的所有不为 x 的点。
输出 g(1),g(2),...,g(n)。

**分析**

dp[v]表示表示以v为根的子树的最长路径，则
`dp[v] = max( max(dp[c1], d[c1]) + w(c1,v), ... max(dp[ck], d[ck]) + w(ck,v), )`

```c++
using S = long long;
using E = int;
vector<int> d;

S op(S x, S y) {
    return x > y ? x : y;
}
S e() {
    return 0;
}
S G(S x, int u, int fa) {
    return x;
}
S F(S x, int u, int fa, E w) {
    return op(x, d[u]) + w;
}
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    
    int n;
    cin >> n;

    ReRooting<S, op, e, G, E, F> g(n);
    for (int i = 1, u, v, w; i < n; ++i) {
        cin >> u >> v >> w;
        u--, v--;
        g.add_edge(u, v, w);
    }
    d.resize(n);
    for (int i = 0; i < n; ++i) {
         cin >> d[i];   
    }

    auto a = g.get();
    for (int i = 0; i < n; ++i) {
        cout << a[i] << "\n";
    }

    return 0;
}
```

