---
layout: post
title: 莫队算法
date: 2023-01-25
tags: 算法专题  
---


===

Index
---
<!-- TOC -->

- [普通莫队](#普通莫队)
  - [简介与模版](#简介与模版)
  - [区间中有多少个不同的数](#区间中有多少个不同的数)
  - [区间中有多少个逆序对](#区间中有多少个逆序对)
- [树上莫队](#树上莫队)

   
<!-- /TOC -->


### 简介与模版

莫队，是一种解决区间查询等问题的离线算法，基于分块思想，复杂度为 O(n·sqrt(n)) 。

一般来说，如果可以在 O(1) 内从 [l,r] 的答案转移到 [l-1,r], [l+1,r], [l,r-1], [l,r+1]  这四个与之紧邻的区间的答案，则可以考虑使用莫队。

**模板**

```c++
struct Mo {
  int width;
  vector<int> left, right, order;

  Mo(int N, int Q) : order(Q) {
    width = max<int>(1, 1.0 * N / max<double>(1.0, sqrt(Q * 2.0 / 3.0)));
    iota(begin(order), end(order), 0);
  }

  void insert(int l, int r) { /* [l, r) */
    left.emplace_back(l);
    right.emplace_back(r);
  }

  template <typename AL, typename AR, typename DL, typename DR, typename REM>
  void run(const AL &add_left, const AR &add_right, const DL &delete_left,
           const DR &delete_right, const REM &rem) {
    assert(left.size() == order.size());
    sort(begin(order), end(order), [&](int a, int b) {
      int ablock = left[a] / width, bblock = left[b] / width;
      if (ablock != bblock) return ablock < bblock;
      if (ablock & 1) return right[a] < right[b];
      return right[a] > right[b];
    });
    int nl = 0, nr = 0;
    for (auto idx : order) {
      while (nl > left[idx]) add_left(--nl);
      while (nr < right[idx]) add_right(nr++);
      while (nl < left[idx]) delete_left(nl++);
      while (nr > right[idx]) delete_right(--nr);
      rem(idx);
    }
  }
};

```

**使用**

使用时需定义如下函数:

```c++
Mo mo(n, q);   // n个元素，q次询问

for (int i = 0, l, r; i < q; ++i) {
    cin >> l >> r;
    mo.insert(l, r);  //query [l, r - 1]
} 

vector<long long> ans(q);
auto add_l = [&](int x) {

};
auto add_r = [&](int x) {

};
auto del_l = [&](int x) {

};
auto del_r = [&](int x) {

};

auto rem = [&](int x) { ans[x] = ...; };
mo.run(add_l,add_r,del_l,del_r,rem);
```

### 区间中有多少个不同的数

给出一个序列a,和q个查询 [l, r]，问[l, r]中有多少个不同的数。

+ 1 <= n <= 3e4
+ 1 <= q <= 2e5
+ 1 <= l <= r <= n
+ 1 < a[i] < 1e6

```c++
#include<bits/stdc++.h>
using namespace std;

// 模版

int main() {
    ios::sync_with_stdio(false); 
    cin.tie(nullptr);

    int n, q, mx = 0;
    cin >> n;

    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];    
        mx = max(mx, a[i]);
    }
    cin >> q;
    Mo mo(n, q);   // n个元素，q次询问
    for (int i = 0, l, r; i < q; ++i) {
        cin >> l >> r;
        mo.insert(l-1, r);  //query [l, r - 1]
    } 

    vector<int> ans(q), cnt(mx + 1);
    int cur = 0;
    auto add_l = [&](int x) {
        if (cnt[a[x]] == 0) cur++;
        cnt[a[x]]++;
    };
    auto add_r = [&](int x) {
        if (cnt[a[x]] == 0) cur++;
        cnt[a[x]]++;
    };
    auto del_l = [&](int x) {
        cnt[a[x]]--;
        if (cnt[a[x]] == 0) cur--;
    };
    auto del_r = [&](int x) {
        cnt[a[x]]--;
        if (cnt[a[x]] == 0) cur--;
    };

    auto rem = [&](int x) { ans[x] = cur; };
    mo.run(add_l,add_r,del_l,del_r,rem);

    for (int i = 0; i < q; ++i)
       cout << ans[i] << "\n";
}
```

### 区间中有多少个逆序对

给出一个序列a,和q个查询 [l, r)，问[l, r)中有多少个逆序对。

+ 1 <= n, q <= 1e5
+ 1 <= a[i] <= 1e9
+ 0 <= l < r <= n

```c++
#include<bits/stdc++.h>
using namespace std;

// 模版

int main() {
    ios::sync_with_stdio(false);  cin.tie(nullptr);

    int n, q;
    cin >> n >> q;

    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];    
    }
    Mo mo(n, q);   // n个元素，q次询问
    for (int i = 0, l, r; i < q; ++i) {
        cin >> l >> r;
        mo.insert(l, r);  //query [l, r - 1]
    } 

    Discretization<int> v(a);   //离散化
    FenwickTree<int> b(v.size());
    for (int i = 0; i < n; ++i) {
        a[i] = v(a[i]); 
    }

    long long cnt = 0;
    vector<long long> ans(q);
    auto add_l = [&](int x) {
        cnt += b.ask(0, a[x] - 1);
        b.add(a[x], 1);
    };
    auto add_r = [&](int x) {
        cnt += b.ask(a[x] + 1, v.size());
        b.add(a[x], 1);
    };
    auto del_l = [&](int x) {
        cnt -= b.ask(0, a[x] - 1);
        b.add(a[x], -1);
    };
    auto del_r = [&](int x) {
        cnt -= b.ask(a[x] + 1, v.size());
        b.add(a[x], -1);
    };

    auto rem = [&](int x) { ans[x] = cnt; };
    mo.run(add_l,add_r,del_l,del_r,rem);

    for (int i = 0; i < q; ++i)
        cout << ans[i] << " \n"[i == q - 1];
}
```