---
layout: post
title: 字符串算法
date: 2022-04-09
tags: 算法专题  
---


===

Index
---
<!-- TOC -->

- [字符串哈希](#字符串哈希)
    - [acwing841](#acwing841)
- [字典树](#字典树)
    - [字符串统计](#字符串统计)
- [kmp算法](#kmp算法)
- [z函数](#z函数)
- [ac自动机](#ac自动机)
    -[简单版](#简单版)
    -[强化版](#强化版)
- [manacher算法](#manacher算法)
- [字符串最小表示](#字符串最小表示)
- [lyndon分解](#lyndon分解)
- [子串分值和](#子串分值和)
- [子串唯一字符和](#子串唯一字符和)
- [每个位置开始的回文串数目](#每个位置开始的回文串数目)
- [最大波动子字符串](#最大波动子字符串)
- [统计子串](#统计子串)
- [有趣子串计数](#有趣子串计数)
- [统计不同回文子序列](#统计不同回文子序列)

   
<!-- /TOC -->


## 字符串哈希

前缀哈希法：

对于一个长度为n的字符串s来说，我们可以这样定义多项式 Hash 函数：

```
s = s[1], s[2], ... , s[n]
f(s) = (s[1]*b^(n-1) + s[2]*b^(n-2),+ ... + s[n]*b^0) % M
```

例如，对于字符串 "xyz"，其哈希函数值为 `x*b^2 + y*b + z`

设 h[i] 表示 s的前i个字符的哈希值，则，s[i]到s[j]的子串哈希值为 
`h[j] - h[l-1] * b^(r-l+1)`

双哈希模板

```c++
using ull = unsigned long long;
struct StrHash{
    const int P1 = 131, P2 = 13331; //or 131
    vector<ull> h1,h2,p1,p2;
    StrHash(){h1={0},h2={0},p1={1},p2={1};}
    StrHash(string s){
        h1={0},h2={0},p1={1},p2={1};
        add(s);
    }
    void add(char c) {
        h1.push_back(h1.back() * P1 + c);
        p1.push_back(p1.back() * P1);
        h2.push_back(h2.back() * P2 + c);
        p2.push_back(p2.back() * P2);
    }
    void add(string s){
        int n = s.size();
        for(int i = 0;i < n; ++i) {
            add(s[i]);
        }
    }
    vector<ull> get(int l, int r) {
        //s[l],...s[r];
        return {h1[r+1]-h1[l]*p1[r-l+1],h2[r+1]-h2[l]*p2[r-l+1]};
    }
};
```

**复杂版模板**

```c++
template<const unsigned &MOD>
struct _m_uint {
    unsigned val;
 
    _m_uint(int64_t v = 0) {
        if (v < 0) v = v % MOD + MOD;
        if (v >= MOD) v %= MOD;
        val = unsigned(v);
    }
 
    _m_uint(uint64_t v) {
        if (v >= MOD) v %= MOD;
        val = unsigned(v);
    }
 
    _m_uint(int v) : _m_uint(int64_t(v)) {}
    _m_uint(unsigned v) : _m_uint(uint64_t(v)) {}
 
    explicit operator unsigned() const { return val; }
    explicit operator int64_t() const { return val; }
    explicit operator uint64_t() const { return val; }
    explicit operator double() const { return val; }
    explicit operator long double() const { return val; }
 
    _m_uint& operator+=(const _m_uint &other) {
        val = val < MOD - other.val ? val + other.val : val - (MOD - other.val);
        return *this;
    }
 
    _m_uint& operator-=(const _m_uint &other) {
        val = val < other.val ? val + (MOD - other.val) : val - other.val;
        return *this;
    }
 
    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {
#if !defined(_WIN32) || defined(_WIN64)
        return unsigned(x % m);
#endif
        // Optimized mod for Codeforces 32-bit machines.
        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.
        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);
        unsigned quot, rem;
        asm("divl %4\n"
            : "=a" (quot), "=d" (rem)
            : "d" (x_high), "a" (x_low), "r" (m));
        return rem;
    }
 
    _m_uint& operator*=(const _m_uint &other) {
        val = fast_mod(uint64_t(val) * other.val);
        return *this;
    }
 
    _m_uint& operator/=(const _m_uint &other) {
        return *this *= other.inv();
    }
 
    friend _m_uint operator+(const _m_uint &a, const _m_uint &b) { return _m_uint(a) += b; }
    friend _m_uint operator-(const _m_uint &a, const _m_uint &b) { return _m_uint(a) -= b; }
    friend _m_uint operator*(const _m_uint &a, const _m_uint &b) { return _m_uint(a) *= b; }
    friend _m_uint operator/(const _m_uint &a, const _m_uint &b) { return _m_uint(a) /= b; }
 
    _m_uint& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
 
    _m_uint& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
 
    _m_uint operator++(int) { _m_uint before = *this; ++*this; return before; }
    _m_uint operator--(int) { _m_uint before = *this; --*this; return before; }
 
    _m_uint operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
 
    friend bool operator==(const _m_uint &a, const _m_uint &b) { return a.val == b.val; }
    friend bool operator!=(const _m_uint &a, const _m_uint &b) { return a.val != b.val; }
    friend bool operator<(const _m_uint &a, const _m_uint &b) { return a.val < b.val; }
    friend bool operator>(const _m_uint &a, const _m_uint &b) { return a.val > b.val; }
    friend bool operator<=(const _m_uint &a, const _m_uint &b) { return a.val <= b.val; }
    friend bool operator>=(const _m_uint &a, const _m_uint &b) { return a.val >= b.val; }
 
    static const int SAVE_INV = int(1e6) + 5;
    static _m_uint save_inv[SAVE_INV];
 
    static void prepare_inv() {
        // Ensures that MOD is prime, which is necessary for the inverse algorithm below.
        for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1)
            assert(MOD % p != 0);
 
        save_inv[0] = 0;
        save_inv[1] = 1;
 
        for (int i = 2; i < SAVE_INV; i++)
            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);
    }
 
    _m_uint inv() const {
        if (save_inv[1] == 0)
            prepare_inv();
 
        if (val < SAVE_INV)
            return save_inv[val];
 
        _m_uint product = 1;
        unsigned v = val;
 
        do {
            product *= MOD - MOD / v;
            v = MOD % v;
        } while (v >= SAVE_INV);
 
        return product * save_inv[v];
    }
 
    _m_uint pow(int64_t p) const {
        if (p < 0)
            return inv().pow(-p);
 
        _m_uint a = *this, result = 1;
 
        while (p > 0) {
            if (p & 1)
                result *= a;
 
            p >>= 1;
 
            if (p > 0)
                a *= a;
        }
 
        return result;
    }
 
    friend ostream& operator<<(ostream &os, const _m_uint &m) {
        return os << m.val;
    }
};
 
template<const unsigned &MOD> _m_uint<MOD> _m_uint<MOD>::save_inv[_m_uint<MOD>::SAVE_INV];
auto random_address = [] { char *p = new char; delete p; return uint64_t(p); };
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1));
extern const unsigned HASH_P = unsigned(-13337);
using hash_int = _m_uint<HASH_P>;
 
const uint64_t HASH_P2 = uint64_t(HASH_P) * HASH_P;
const int HASH_COUNT = 2;
 
// Avoid multiplication bases near 0 or P - 1.
uniform_int_distribution<unsigned> MULT_DIST(unsigned(0.1 * HASH_P), unsigned(0.9 * HASH_P));
const hash_int HASH_MULT[] = {MULT_DIST(rng), MULT_DIST(rng)};
const hash_int HASH_INV[] = {1 / HASH_MULT[0], 1 / HASH_MULT[1]};
 
vector<hash_int> hash_pow[] = {{1}, {1}};
 
const int INF = int(1e9) + 5;
 
template<typename T_string = string>
struct string_hash {
    static const bool BUILD_REVERSE = true;
 
    static uint64_t hash(const T_string &str) {
        uint64_t result = 0;
 
        for (int h = 0; h < HASH_COUNT; h++) {
            uint64_t value = 1;
 
            for (const auto &x : str)
                value = (uint64_t(HASH_MULT[h]) * value + x) % HASH_P;
 
            result += value << (32 * h);
        }
 
        return result;
    }
 
    T_string str;
    vector<hash_int> _prefix[HASH_COUNT];
    vector<hash_int> _inv_prefix[HASH_COUNT];
 
    string_hash() {
        build({});
    }
 
    string_hash(const T_string &_str) {
        build(_str);
    }
 
    int length() const {
        return int(_prefix[0].size()) - 1;
    }
 
    template<typename T_char>
    void add_char(const T_char &c) {
        str.push_back(c);
 
        for (int h = 0; h < HASH_COUNT; h++) {
            _prefix[h].push_back(HASH_MULT[h] * _prefix[h].back() + c);
 
            if (hash_pow[h].size() < _prefix[h].size())
                hash_pow[h].push_back(HASH_MULT[h] * hash_pow[h].back());
 
            if (BUILD_REVERSE)
                _inv_prefix[h].push_back((_inv_prefix[h].back() + c) * HASH_INV[h]);
        }
    }
 
    void pop_char() {
        str.pop_back();
 
        for (int h = 0; h < HASH_COUNT; h++) {
            _prefix[h].pop_back();
 
            if (BUILD_REVERSE)
                _inv_prefix[h].pop_back();
        }
    }
 
    void build(const T_string &_str) {
        str = {};
        str.reserve(_str.size());
 
        for (int h = 0; h < HASH_COUNT; h++) {
            hash_pow[h].reserve(_str.size() + 1);
            _prefix[h] = {0};
            _prefix[h].reserve(_str.size() + 1);
 
            if (BUILD_REVERSE) {
                _inv_prefix[h] = {0};
                _inv_prefix[h].reserve(_str.size() + 1);
            }
        }
 
        for (auto &c : _str)
            add_char(c);
    }
 
    uint64_t _single_hash(int h, int start, int end) const {
        // Convert everything to `uint64_t` for speed. Note: we add hash_pow[length] to fix strings that start with 0.
        uint64_t power = uint64_t(hash_pow[h][end - start]);
        return (power + uint64_t(_prefix[h][end]) + HASH_P2 - uint64_t(_prefix[h][start]) * power) % HASH_P;
    }
 
    uint64_t substring_hash(int start, int end) const {
        assert(0 <= start && start <= end && end <= length());
        return _single_hash(0, start, end) + (HASH_COUNT > 1 ? _single_hash(1, start, end) << 32 : 0);
    }
 
    uint64_t complete_hash() const {
        return substring_hash(0, length());
    }
 
    uint64_t _reverse_single_hash(int h, int start, int end) const {
        // Convert everything to `uint64_t` for speed. Note: we add hash_pow[length] to fix strings that start with 0.
        uint64_t power = uint64_t(hash_pow[h][end - start]);
        return (power + uint64_t(_inv_prefix[h][end]) * power + HASH_P - uint64_t(_inv_prefix[h][start])) % HASH_P;
    }
 
    uint64_t reverse_substring_hash(int start, int end) const {
        assert(0 <= start && start <= end && end <= length());
        return _reverse_single_hash(0, start, end) + (HASH_COUNT > 1 ? _reverse_single_hash(1, start, end) << 32 : 0);
    }
 
    uint64_t reverse_complete_hash() const {
        return reverse_substring_hash(0, length());
    }
 
    bool equal(int start1, int start2, int length) const {
        return substring_hash(start1, start1 + length) == substring_hash(start2, start2 + length);
    }
 
    bool is_palindrome(int start, int end) const {
        return substring_hash(start, end) == reverse_substring_hash(start, end);
    }
 
    int compare(int start1, int start2, int max_length = INF) const;
};
 
uint64_t concat_hashes(uint64_t hash1, uint64_t hash2, int len2) {
    if (len2 == 0) return hash1;
    uint64_t hash1_low = hash1 & unsigned(-1);
    uint64_t hash2_low = hash2 & unsigned(-1);
    uint64_t power = uint64_t(hash_pow[0][len2]);
    uint64_t combined = (hash1_low * power + hash2_low + HASH_P - power) % HASH_P;
 
    if (HASH_COUNT > 1) {
        hash1 >>= 32;
        hash2 >>= 32;
        power = uint64_t(hash_pow[1][len2]);
        combined += (hash1 * power + hash2 + HASH_P - power) % HASH_P << 32;
    }
 
    return combined;
}
 
template<typename T_string>
int first_mismatch(const string_hash<T_string> &hash1, int start1,
                   const string_hash<T_string> &hash2, int start2, int max_length = INF) {
    max_length = min({max_length, hash1.length() - start1, hash2.length() - start2});
 
    static const int FIRST = 5;
    int first = min(max_length, FIRST);
 
    for (int i = 0; i < first; i++)
        if (hash1.str[start1 + i] != hash2.str[start2 + i])
            return i;
 
    if (hash1.substring_hash(start1, start1 + max_length) == hash2.substring_hash(start2, start2 + max_length))
        return max_length;
 
    static const int MANUAL = 15;
    int low = first, high = max_length - 1;
 
    while (high - low > MANUAL) {
        int mid = (low + high + 1) / 2;
 
        if (hash1.substring_hash(start1, start1 + mid) == hash2.substring_hash(start2, start2 + mid))
            low = mid;
        else
            high = mid - 1;
    }
 
    for (int i = low; i < high; i++)
        if (hash1.str[start1 + i] != hash2.str[start2 + i])
            return i;
 
    return high;
}
 
template<typename T_string>
int hash_compare(const string_hash<T_string> &hash1, int start1,
                 const string_hash<T_string> &hash2, int start2, int max_length = INF) {
    int mismatch = first_mismatch(hash1, start1, hash2, start2, max_length);
    int length1 = min(hash1.length() - start1, max_length);
    int length2 = min(hash2.length() - start2, max_length);
 
    if (mismatch == min(length1, length2))
        return length1 == length2 ? 0 : (length1 < length2 ? -1 : +1);
 
    if (hash1.str[start1 + mismatch] == hash2.str[start2 + mismatch])
        return 0;
 
    return hash1.str[start1 + mismatch] < hash2.str[start2 + mismatch] ? -1 : +1;
}
 
template<typename T_string>
int string_hash<T_string>::compare(int start1, int start2, int max_length) const {
    return hash_compare(*this, start1, *this, start2, max_length);
}
```

**使用方法**

1. 定义哈希字符串

`string_hash<string> f(s);`

2. 获取s[i...j]的哈希值 [i，j+1) 左闭右开。

`f.substring_hash(i, j + 1)`



### acwing841

[acwing 841](https://www.acwing.com/problem/content/843/)

给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

```c++
struct StrHash{
    ...
};
int main() {
    int n,m;
    scanf("%d%d",&n,&m);
    string s;
    cin>>s;
    StrHash sh(s);
    while(m--){
        int l1,r1,l2,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        if(sh.get(l1,r1)==sh.get(l2,r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

**模板2**

```c++
int main(){
    int n,m;
    string s;
    cin>>n>>m>>s;
    long long ans=0;
    string_hash<string> f(s);
    while(m--){
        int l1,l2,r1,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        if(f.substring_hash(l1-1,r1)==f.substring_hash(l2-1,r2)) puts("Yes");
        else puts("No");
    }
}
```



## 字典树

### 字符串统计

[acwing 835](https://www.acwing.com/problem/content/837/)

维护一个字符串集合，支持两种操作：

- I x 向集合中插入一个字符串 x；
- Q x 询问一个字符串在集合中出现了多少次。

共有 N 个操作，输入的字符串总长度不超过 1e5，字符串仅包含小写英文字母。

```c++
#include <iostream>
using namespace std;

const int N = 100010;

int son[N][26], cnt[N], idx;

void insert(string s) {
    int p = 0;
    for (int i = 0; i < s.size(); i ++ ) {
        int u = s[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

int query(string s) {
    int p = 0;
    for (int i = 0; i < s.size(); i ++ ) {
        int u = s[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

int main() {
    int n;
    scanf("%d", &n);
    while (n -- ) {
        string s,op;
        cin>>op>>s;
        if (op[0] == 'I') insert(s);
        else printf("%d\n", query(s));
    }
    return 0;
}
```

### kmp算法

[acwing 831](https://www.acwing.com/problem/content/description/833/)

给定两个字符串s和t,求s在t中所有出现位置的下标。

```c++
vector<int> kmp(string s, string t) {
    int n = s.size(), m = t.size();
    vector<int> nxt(n+1), res;
    for (int i = 1, j = 0; i < n; ++i) {
        while (j && s[i] != s[j]) j = nxt[j - 1];
        if (s[i] == s[j]) j++;
        nxt[i] = j;
    }
    for (int i = 0, j = 0; i < m; ++i) {
        while(j && t[i] != s[j]) j = nxt[j - 1];
        if (t[i] == s[j]) {
            j++;
            if (j == n) {
                res.push_back(i - n + 1);
                j = nxt[n - 1];
            }
        }
    }
    return res;
}
```

### z函数

对于长度为n的字符串s，定义函数z[i]表示s和s[i,n-1]（即以s[i]开头的后缀）的最长公共前缀的长度，z被称为s的z函数。


[leetcode 2223](https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/)


```c++
class Solution {
public:
    vector<int> z_function(string& s) {
        int n = s.size();
        vector<int> z(n, n);
        for (int i = 1, l = 0, r = 0; i < n; i += 1) {
            if (i <= r and z[i - l] < r - i + 1) z[i] = z[i - l];
            else for (z[i] = max(0, r - i + 1); i + z[i] < n && s[z[i]] == s[i + z[i]]; z[i] += 1);
            if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
        }
        return z;
    }
    long long sumScores(string s) {
        vector<int> z = z_function(s);
        long long c = 0;
        for(auto&x: z) c+=x;
        return c;
    }
};
```


## ac自动机

### 简单版

给定 n 个模式串 s[i] 和一个文本串 t，求有多少个不同的模式串在文本串里出现过。
两个模式串不同当且仅当他们编号不同。

[洛谷p3808](https://www.luogu.com.cn/problem/P3808)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 6;
int n;

namespace AC {
int tr[N][26], tot;
int e[N], fail[N];

void insert(char *s) {
  int u = 0;
  for (int i = 1; s[i]; i++) {
    if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;  // 如果没有则插入新节点
    u = tr[u][s[i] - 'a'];                              // 搜索下一个节点
  }
  e[u]++;  // 尾为节点 u 的串的个数
}

queue<int> q;

void build() {
  for (int i = 0; i < 26; i++)
    if (tr[0][i]) q.push(tr[0][i]);
  while (q.size()) {
    int u = q.front();
    q.pop();
    for (int i = 0; i < 26; i++) {
      if (tr[u][i]) {
        fail[tr[u][i]] =
            tr[fail[u]][i];  // fail数组：同一字符可以匹配的其他位置
        q.push(tr[u][i]);
      } else
        tr[u][i] = tr[fail[u]][i];
    }
  }
}

int query(char *t) {
  int u = 0, res = 0;
  for (int i = 1; t[i]; i++) {
    u = tr[u][t[i] - 'a'];  // 转移
    for (int j = u; j && e[j] != -1; j = fail[j]) {
      res += e[j], e[j] = -1;
    }
  }
  return res;
}
}  // namespace AC

char s[N];

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) scanf("%s", s + 1), AC::insert(s);
  scanf("%s", s + 1);
  AC::build();
  printf("%d", AC::query(s));
  return 0;
}
```

### 强化版

有 N 个由小写字母组成的模式串以及一个文本串 T。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串 T 中出现的次数最多。

[洛谷p2796](https://www.luogu.com.cn/problem/P3796)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 156, L = 1e6 + 6;

namespace AC {
const int SZ = N * 80;
int tot, tr[SZ][26];
int fail[SZ], idx[SZ], val[SZ];
int cnt[N];  // 记录第 i 个字符串的出现次数

void init() {
  memset(fail, 0, sizeof(fail));
  memset(tr, 0, sizeof(tr));
  memset(val, 0, sizeof(val));
  memset(cnt, 0, sizeof(cnt));
  memset(idx, 0, sizeof(idx));
  tot = 0;
}

void insert(char *s, int id) {  // id 表示原始字符串的编号
  int u = 0;
  for (int i = 1; s[i]; i++) {
    if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;
    u = tr[u][s[i] - 'a'];  // 转移
  }
  idx[u] = id;  // 以 u 为结尾的字符串编号为 idx[u]
}

queue<int> q;

void build() {
  for (int i = 0; i < 26; i++)
    if (tr[0][i]) q.push(tr[0][i]);
  while (q.size()) {
    int u = q.front();
    q.pop();
    for (int i = 0; i < 26; i++) {
      if (tr[u][i]) {
        fail[tr[u][i]] =
            tr[fail[u]][i];  // fail数组：同一字符可以匹配的其他位置
        q.push(tr[u][i]);
      } else
        tr[u][i] = tr[fail[u]][i];
    }
  }
}

int query(char *t) {  // 返回最大的出现次数
  int u = 0, res = 0;
  for (int i = 1; t[i]; i++) {
    u = tr[u][t[i] - 'a'];
    for (int j = u; j; j = fail[j]) val[j]++;
  }
  for (int i = 0; i <= tot; i++)
    if (idx[i]) res = max(res, val[i]), cnt[idx[i]] = val[i];
  return res;
}
}  // namespace AC

int n;
char s[N][100], t[L];

int main() {
  while (~scanf("%d", &n)) {
    if (n == 0) break;
    AC::init();  // 数组清零
    for (int i = 1; i <= n; i++)
      scanf("%s", s[i] + 1), AC::insert(s[i], i);  // 需要记录该字符串的序号
    AC::build();
    scanf("%s", t + 1);
    int x = AC::query(t);
    printf("%d\n", x);
    for (int i = 1; i <= n; i++)
      if (AC::cnt[i] == x) printf("%s\n", s[i] + 1);
  }
  return 0;
}
```

### manacher算法

给定长度为n的字符串s，找出所有对(i,j)，使得s[i,j]为一个回文串。

对于每个位置 i=0,1,...,n-1,我们找出值d1[i]和d2[i],二者分别表示以位置 i 为中心的长度为奇数和长度为偶数的回文串个数, 换个角度，二者也表示了以位置 i 为中心的最长回文串的半径长度（半径长度 d1[i]，d2[i] 均为从位置 i 到回文串最右端位置包含的字符个数）。


```c++
void manacher(string s){
    int n = s.size();
    vector<int> d1(n), d2(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
        d1[i] = k--;
        if (i + k > r) l = i - k, r = i + k;
    }
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
        d2[i] = k--;
        if (i + k > r) l = i - k - 1, r = i + k;
    }
}
```


[lc5 最长回文子串](#https://leetcode-cn.com/problems/longest-palindromic-substring/)

```c++
class Solution {
public:
    string manacher(string s){
        int n = s.size();
        vector<int> d1(n), d2(n);
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
            d1[i] = k--;
            if (i + k > r) l = i - k, r = i + k;
        }
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
            d2[i] = k--;
            if (i + k > r) l = i - k - 1, r = i + k;
        }
        string t;
        int mx=0;
        for(int i=0;i<n;++i){
            mx=max(mx,max(2*d1[i]-1,d2[i]*2));
        }
        for(int i=0;i<n;++i){
            if(2*d1[i]-1==mx){
                t=s.substr(i-d1[i]+1,mx);
                break;
            }else if(d2[i]*2==mx){
                 t=s.substr(i-d2[i],mx);
                 break;
            }
        }
        return t;
    }
    string longestPalindrome(string s) {
        return manacher(s);
    }
};
```

### 字符串最小表示

当字符串 s 中可以选定一个位置 i 满足
`s[i...n] + s[1...i-1] == T`
则称 s 与 T 循环同构.

**最小表示**

字符串 s 的最小表示为与 s 循环同构的所有字符串中字典序最小的字符串

最小表示的O(n)算法


```c++
string min_rep(string s){
    int k = 0, i = 0, j = 1, n = s.size();
    while (k < n && i < n && j < n) {
        if (s[(i + k) % n] == s[(j + k) % n]) k++;
        else {
            s[(i + k) % n] > s[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
            if (i == j) i++;
            k = 0;
        }
    }
    i = min(i, j);
    return s.substr(i)+s.substr(0,i);
}
```

### lyndon分解

**Lyndon 串** : 对于字符串 s，如果 s 的字典序严格小于 s 的所有后缀的字典序，我们称 s 是 **简单串** 或者 **Lyndon 串**。

例如：`a, ab, aab, abb, ababb, abcd` 都是简单串。


**结论1**

当且仅当s的字典序严格小于它的所有非平凡(非空且不同于本身)循环同构串时，s才是简单串。

**Lyndon分解**： 串s的Lyndon分解记为 s=w1w2... wk，其中所有wi为简单串，并且他们的字典序按照非严格单减排序，即

`w1 >= w2 >= ..., >= wk`。这样的分解存在且唯一。


**Duval算法**

Duval可以在**O(n)**时间内求出一个串的Lyndon分解。

```c++
vector<string> duval(string const& s) {
  int n = s.size(), i = 0;
  vector<string> factorization;
  while (i < n) {
    int j = i + 1, k = i;
    while (j < n && s[k] <= s[j]) {
      if (s[k] < s[j])
        k = i;
      else
        k++;
      j++;
    }
    while (i <= k) {
      factorization.push_back(s.substr(i, j - k));
      i += j - k;
    }
  }
  return factorization;
}
```

**最小表示法**

```c++
string min_cyclic_string(string s) {
  s += s;
  int n = s.size();
  int i = 0, ans = 0;
  while (i < n / 2) {
    ans = i;
    int j = i + 1, k = i;
    while (j < n && s[k] <= s[j]) {
      if (s[k] < s[j])
        k = i;
      else
        k++;
      j++;
    }
    while (i <= k) i += j - k;
  }
  return s.substr(ans, n / 2);
}
```

### 子串分值和

子串的 **分值** 定义为字符串中不同字符的数量。
例如 "abbca" 分值为3，因为其有3个不同字符。

给你一个字符串 s, 返回其所有子字符串的总分值。

[leetcode 周赛291 p4](https://leetcode.cn/contest/weekly-contest-291/problems/total-appeal-of-a-string/)


**分析**

对于一个长度为n的字符串，我们考虑其所有子串的个数，可以考虑以下做法，

考虑第i个字符，它和前面字符加起来长度为x, 和后面字符加起来长度为y，则包含字符i的所有子串数目有 `x * y`个.

例如对于`abcd`, 其子串个数为 `1*4 + 2*3 + 3*2 + 4*1` ，
那么我们考虑每个字符在包含它的所有子串，然后减去重复即可，什么样的是重复的呢？ 我们从左向右考虑每个字符，那么前面第一个和该字符相同的字符的前缀就是重复计算的，我们减去这段前缀长度即可。

例如 `XXXXabcaXXXX` 对于第一个a我们可以没有顾虑的统计，加上包含它的所有子串即可，对于第二个a，显然我们统计其前缀时可能包含第一个a，设第一个a的下标为z，上述计算子串的公式在这里就要转化为 `(x-z)*y` 。

```c++
class Solution {
public:
    long long appealSum(string s) {
        long long c = 0, n = s.size();
        vector<long long> p(26, -1);
        for (int i = 0; i < n; ++i) {
            c += (i - p[s[i] - 'a']) * (n - i);
            p[s[i] - 'a'] = i;
        }
        return c;
    }
};
```

### 子串唯一字符和

我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。

给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。

由于答案可能非常大，请将结果 mod 10 ^ 9 + 7 后再返回。

[lc周赛83 p4](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)

**分析**

考虑这样一个问题，对于s中任一个字符 `s[i]` ，s 中有多少个子串只包含一个 `s[i]`， 假设有一段子串是这样的 `aXXXXaXXXXXa` ，其中x为不等于a的其他字符，只包含中间那个a的所有子串共有 5 * 6 = 30个，其中开始位置可以为
`XXXXa`中的任一个，结束位置可以为 `aXXXXX`中的任一个。

最后对于每个字符 c，将计数结果进行累加，就得到了最终的答案。

```c++
class Solution {
public:
    int uniqueLetterString(string s) {
        int mod = 1e9 + 7, n = s.size(), ans = 0;
        for (int i = 0; i < n; ++i) {
            int j = i - 1, k = i + 1;
            while (j >= 0 && s[j] != s[i]) j--;
            while (k < n && s[k] != s[i]) k++;
            ans = (ans + (i - j) * (k - i)) % mod;
        }
        return ans;
    }
};
```


### 每个位置开始的回文串数目

[牛客acm同步赛](#https://ac.nowcoder.com/acm/contest/33540/A)

给出一个序列 a, 对于i，求满足如下条件的j的数目。
- i <= j
- a[i],...,a[j] 是一个回文串
- 1 <= n <= 1e6

**分析**

manacher算法 中的 d1[i]和d2[i],二者分别表示以位置 i 为中心的长度为奇数和长度为偶数的回文串个数，也表示了以位置 i 为中心的最长回文串的半径长度

那么对于每个中心点j，在 [j+1-d1[j], j]之间的每个i，j都满足上述条件，使用 差分数组，可以在o(n)时间内
求出每个i满足的j的数目，由于长度为偶数和奇数都会将j本身计算一边，最后结果需要减去1。

```c++
vector<int> cal(vector<int>& s) {
    int n = s.size(), sum = 0;
    vector<int> d1(n), d2(n), c(n), res(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
        d1[i] = k--;
        if (i + k > r) l = i - k, r = i + k;
    }
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
        d2[i] = k--;
        if (i + k > r) l = i - k - 1, r = i + k;
    }
    for (int i = 0; i < n; ++i) {
        c[i +1 - d1[i]]++, c[i + 1]--;
        c[i - d2[i]]++, c[i + 1]--;
    }
    for (int i = 0; i < n; ++i) {
        sum += c[i];
        res[i] = sum - 1;
    }
    return res;
}
```

### 最大波动子字符串

[双周赛78T4](https://leetcode.cn/problems/substring-with-largest-variance/)

字符串的**波动**定义为字符串中**出现次数最多**的字符与**出现次数最少**的字符次数之差。

给你一个字符串s，只包含小写字母，求s所有**子字符串**的**最大波动值**。

**分析**

枚举哪个字符是出现最多的（记为 x），哪个字符是出现最少的（记为 y）。把字符串中所有 x 改成 1，所有 y 改成 -1，其它的都改成 0。那么该序列的最大非空子段和就是以 x 为出现最多字符，y 为出现最少字符的答案。

注意x和y必须都出现在子串中，不能吧只有x的子串作为答案，。
我们可以用变量 d1 维护 x和y的出现次数之差，初始值为0.

同时用另一个变量 d2 维护在包含y是的x和y出现次数之差，初始为负无穷。因为还没有遇到y。遍历字符串s：

+ 当遇到x时， d1 和 d2 均加1
+ 当遇到y时， d1 减1，d1记录此时的 d1值，若 d1位负，则将其置零。


```c++
class Solution {
public:
    int largestVariance(string s) {
        int n = s.size(), ans = 0;
        for (char x = 'a'; x <= 'z'; ++x) {
            for (char y = 'a'; y <= 'z'; ++y) {
                if (x == y) continue;
                int d1 = 0, d2 = -n;
                for (auto c : s) {
                    if (c == x) d1++, d2++;
                    else if (c == y) {
                        d2 = -- d1;
                        d1 = max(d1, 0);
                    }
                    ans = max(ans, d2);
                }
            }
        }
        return ans;
    }
};
```

### 统计子串

给定长度为n的01串及整数k，需要回答q个询问。第i个询问为[li,ri],

求s[l,r]中有多少子串，该子串中没有字符出现次数超过k次。

+ 1 <= k <= n <= 1e5
+ 1 <= q <= 1e5
+ 1 <= l <= r <= n

**分析**

设 l[i] 是最大的下标j，使得 s[i,j] 包含至多k个0和k个1。

对于一个查询 [L,R]。 以下标i开始的有效string共有 min(R,l[i]) - i + 1。

所以对于查询[L,R] 的答案为

```
(l[i]-i+1) + ... + (l[k]-k+1) + (R-(k+1)+1) + ... + (R - R + 1)
```

其中 k 是满足 l[k] <= R 的最大下标。

我们可以对于每一个R，预处理出对应的k。


+ 时间复杂度 O(n + q)

```c++
vector<long long> countSubString(string s, int k, vector<vector<int>> &q) {
    int n = s.size(), m = q.size();
    vector<int> l(n), r(n), cnt(2);
    for (int i = 0, j = 0; i < n; ++i) {
        while (j < n && cnt[s[j] - '0'] + 1 <= k) cnt[s[j++] - '0']++;
        l[i] = j - 1;
        cnt[s[i] - '0']--;
    }
    cnt = {0, 0};
    for (int i = n - 1, j = n - 1; ~i; --i) {
        while (j >= 0 && cnt[s[j] - '0'] + 1 <= k) cnt[s[j--] - '0']++;
        r[i] = j + 1;
        cnt[s[i] - '0']--;
    }
    vector<long long> p(n + 1), ans(m);
    for (int i = 0; i < n; ++i) 
        p[i + 1] = p[i] + l[i];

    for (int i = 0; i < m; ++i) {
        int x = q[i][0], y = q[i][1], t = r[y] - 1;
        if (x <= t) {
            ans[i] = p[t + 1] - p[x] + 1ll * (y - t) * y;
            ans[i] -= (x + y - 2ll) * (y - x + 1ll) / 2;
        } else {
            ans[i] = (y - x + 2ll) * (y - x + 1ll) / 2;
        }

    }
    return ans;
}
```

### 有趣子串计数

字符串x是有趣的，当且仅当它满足下面的条件：

+ x 包含至少 k 中不同字符
+ x 中任意字符出现的次数相等

给定字符串 S，请求出它有多少子串是有趣的。

+ 1 <= s.length <= 5000
+ s 中只包含小写字母

**分析**

子串s[i,j]是有趣的，只需满足以下条件：

+ 子串 包含至少 k 中不同字符
+ 子串中出现次数最多的字符的出现次数与包含的不同字符数乘积等于子串长度


```c++
int countSubString(string &s, int k) {
    int n = s.size(), ans = 0;
    for (int i = 0; i < n; ++i) {
        map<int, int> mp;
        int mx = 0, cnt = 0;
        for (int j = i; ~j; --j) {
            mp[s[j]]++;
            mx = max(mx, mp[s[j]]);
            if (mx * (int)(mp.size()) == (i - j + 1) && (int)mp.size() >= k)
                ans++;
        }
    }
}
```

### 统计不同回文子序列

[leetcode 730](https://leetcode.cn/problems/count-different-palindromic-subsequences/)

定一个字符串 s，返回 s 中不同的非空 回文子序列 个数 。

+ 1 <= s.length <= 1000
+ s[i] 仅包含 a,b,c,d

```c++
class Solution {
public:
    int countPalindromicSubsequences(string s) {
        int n = s.size(), P = 1e9 + 7;
        vector dp(n, vector<int>(n));
        for (int i = 0; i < n; ++i) 
            dp[i][i] = 1;
        for (int len = 2; len <= n; ++len) {
            for (int i = 0; i + len <= n; ++i) {
                int j = i + len - 1;
                if (s[i] == s[j]) {
                    int l = i + 1, r = j - 1;
                    while (l <= r && s[l] != s[i]) l++;
                    while (r >= l && s[r] != s[j]) r--;
                    if (l > r) 
                        dp[i][j] = (2 + dp[i + 1][j - 1] * 2) % P;
                    else if (l == r)
                        dp[i][j] = (1 + dp[i + 1][j - 1] * 2) % P;
                    else
                        dp[i][j] = (0LL + dp[i + 1][j - 1] * 2 - dp[l + 1][r - 1] + P) % P;
                } else {
                    dp[i][j] = (0LL + dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + P) % P;
                }
            }
        }
        return dp[0][n - 1];
    }
};
```