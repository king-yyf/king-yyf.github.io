---
layout: post
title: å­—ç¬¦ä¸²ç®—æ³•
date: 2022-04-09
tags: ç®—æ³•ä¸“é¢˜  
---


===

Index
---
<!-- TOC -->

- [å­—ç¬¦ä¸²å“ˆå¸Œ](#å­—ç¬¦ä¸²å“ˆå¸Œ)
    - [acwing841](#acwing841)
- [å­—ç¬¦ä¸²å­—å…¸æ ‘](#å­—å…¸æ ‘)
    - [å­—å…¸æ ‘æ¨¡æ¿](#å­—å…¸æ ‘æ¨¡æ¿)
    - [å­—ç¬¦ä¸²ç»Ÿè®¡](#å­—ç¬¦ä¸²ç»Ÿè®¡)
    - [å­—ç¬¦ä¸²çš„å‰ç¼€åˆ†æ•°å’Œ](#å­—ç¬¦ä¸²çš„å‰ç¼€åˆ†æ•°å’Œ)
    - [å­—å…¸æ ‘ç»Ÿè®¡å‰ç¼€](#å­—å…¸æ ‘ç»Ÿè®¡å‰ç¼€)
- [kmpç®—æ³•](#kmpç®—æ³•)
- [zå‡½æ•°](#zå‡½æ•°)
- [acè‡ªåŠ¨æœº](#acè‡ªåŠ¨æœº)
    -[ç®€å•ç‰ˆ](#ç®€å•ç‰ˆ)
    -[å¼ºåŒ–ç‰ˆ](#å¼ºåŒ–ç‰ˆ)
- [manacherç®—æ³•](#manacherç®—æ³•)
    - [æœ€é•¿å›æ–‡å­ä¸²](#æœ€é•¿å›æ–‡å­ä¸²)
    - [å˜æˆå›æ–‡ä¸²æœ€å°‘åœ¨å‰é¢æ·»åŠ å­—ç¬¦æ•°](#å˜æˆå›æ–‡ä¸²æœ€å°‘åœ¨å‰é¢æ·»åŠ å­—ç¬¦æ•°)
    - [æ¯ä¸ªä½ç½®å¼€å§‹çš„å›æ–‡ä¸²æ•°ç›®](#æ¯ä¸ªä½ç½®å¼€å§‹çš„å›æ–‡ä¸²æ•°ç›®)
    - [å‰åç¼€å›æ–‡ä¸²](#å‰åç¼€å›æ–‡ä¸²)
- [å›æ–‡è‡ªåŠ¨æœº](#å›æ–‡è‡ªåŠ¨æœº)
    - [æ¯ä¸ªä½ç½®ç»“æŸçš„å›æ–‡ä¸²æ•°ç›®](#æ¯ä¸ªä½ç½®ç»“æŸçš„å›æ–‡ä¸²æ•°ç›®)
- [å­—ç¬¦ä¸²æœ€å°è¡¨ç¤º](#å­—ç¬¦ä¸²æœ€å°è¡¨ç¤º)
- [lyndonåˆ†è§£](#lyndonåˆ†è§£)
- [å­ä¸²åˆ†å€¼å’Œ](#å­ä¸²åˆ†å€¼å’Œ)
- [å­ä¸²å”¯ä¸€å­—ç¬¦å’Œ](#å­ä¸²å”¯ä¸€å­—ç¬¦å’Œ)
- [æœ€å¤§æ³¢åŠ¨å­å­—ç¬¦ä¸²](#æœ€å¤§æ³¢åŠ¨å­å­—ç¬¦ä¸²)
- [ç»Ÿè®¡å­ä¸²](#ç»Ÿè®¡å­ä¸²)
- [æœ‰è¶£å­ä¸²è®¡æ•°](#æœ‰è¶£å­ä¸²è®¡æ•°)
- [ç»Ÿè®¡ä¸åŒå›æ–‡å­åºåˆ—](#ç»Ÿè®¡ä¸åŒå›æ–‡å­åºåˆ—)

   
<!-- /TOC -->


## å­—ç¬¦ä¸²å“ˆå¸Œ

å‰ç¼€å“ˆå¸Œæ³•ï¼š

å¯¹äºä¸€ä¸ªé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²sæ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å®šä¹‰å¤šé¡¹å¼ Hash å‡½æ•°ï¼š

```
s = s[1], s[2], ... , s[n]
f(s) = (s[1]*b^(n-1) + s[2]*b^(n-2),+ ... + s[n]*b^0) % M
```

ä¾‹å¦‚ï¼Œå¯¹äºå­—ç¬¦ä¸² "xyz"ï¼Œå…¶å“ˆå¸Œå‡½æ•°å€¼ä¸º `x*b^2 + y*b + z`

è®¾ h[i] è¡¨ç¤º sçš„å‰iä¸ªå­—ç¬¦çš„å“ˆå¸Œå€¼ï¼Œåˆ™ï¼Œs[i]åˆ°s[j]çš„å­ä¸²å“ˆå¸Œå€¼ä¸º 
`h[j] - h[l-1] * b^(r-l+1)`

åŒå“ˆå¸Œæ¨¡æ¿

```c++
using ull = unsigned long long;
struct StrHash{
    const int P1 = 131, P2 = 13331; //or 131
    vector<ull> h1,h2,p1,p2;
    StrHash(){h1={0},h2={0},p1={1},p2={1};}
    StrHash(string s){
        h1={0},h2={0},p1={1},p2={1};
        add(s);
    }
    void add(char c) {
        h1.push_back(h1.back() * P1 + c);
        p1.push_back(p1.back() * P1);
        h2.push_back(h2.back() * P2 + c);
        p2.push_back(p2.back() * P2);
    }
    void add(string s){
        int n = s.size();
        for(int i = 0;i < n; ++i) {
            add(s[i]);
        }
    }
    vector<ull> get(int l, int r) {
        //s[l],...s[r];
        return {h1[r+1]-h1[l]*p1[r-l+1],h2[r+1]-h2[l]*p2[r-l+1]};
    }
};
```

**å¤æ‚ç‰ˆæ¨¡æ¿**

[string_hash](https://github.com/king-yyf/leetcode/blob/master/sting_hash.cpp)

**ä½¿ç”¨æ–¹æ³•**

1. å®šä¹‰å“ˆå¸Œå­—ç¬¦ä¸²

`string_hash<string> f(s);`

2. è·å–s[i...j]çš„å“ˆå¸Œå€¼ [iï¼Œj+1) å·¦é—­å³å¼€ã€‚

`f.substring_hash(i, j + 1)`


### acwing841

[acwing 841](https://www.acwing.com/problem/content/843/)

ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„å­—ç¬¦ä¸²ï¼Œå†ç»™å®š m ä¸ªè¯¢é—®ï¼Œæ¯ä¸ªè¯¢é—®åŒ…å«å››ä¸ªæ•´æ•° l1,r1,l2,r2ï¼Œè¯·ä½ åˆ¤æ–­ [l1,r1] å’Œ [l2,r2] è¿™ä¸¤ä¸ªåŒºé—´æ‰€åŒ…å«çš„å­—ç¬¦ä¸²å­ä¸²æ˜¯å¦å®Œå…¨ç›¸åŒã€‚

å­—ç¬¦ä¸²ä¸­åªåŒ…å«å¤§å°å†™è‹±æ–‡å­—æ¯å’Œæ•°å­—ã€‚

```c++
struct StrHash{
    ...
};
int main() {
    int n,m;
    scanf("%d%d",&n,&m);
    string s;
    cin>>s;
    StrHash sh(s);
    while(m--){
        int l1,r1,l2,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        if(sh.get(l1,r1)==sh.get(l2,r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

**æ¨¡æ¿2**

```c++
int main(){
    int n,m;
    string s;
    cin>>n>>m>>s;
    long long ans=0;
    string_hash<string> f(s);
    while(m--){
        int l1,l2,r1,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        if(f.substring_hash(l1-1,r1)==f.substring_hash(l2-1,r2)) puts("Yes");
        else puts("No");
    }
}
```


## å­—å…¸æ ‘


### å­—å…¸æ ‘æ¨¡æ¿

è¯¥å­—å…¸æ ‘æ¨¡æ¿å¯ä»¥ç”¨æ¥æ±‚è§£ï¼š

+ ç»™å®šå­—ç¬¦ä¸²sï¼Œç»Ÿè®¡trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²ç­‰äºs
+ ç»™å®šå­—ç¬¦ä¸²sï¼Œç»Ÿè®¡trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²æ˜¯sçš„å‰ç¼€å­—ç¬¦ä¸²
+ ç»™å®šå­—ç¬¦ä¸²sï¼Œç»Ÿè®¡sæ˜¯trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²çš„å‰ç¼€
+ ç»™å®šå­—ç¬¦ä¸²sï¼Œå¯¹sçš„æ¯ä¸ªå‰ç¼€ä¸²tï¼Œ ç»Ÿè®¡tæ˜¯trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²çš„å‰ç¼€ï¼Œå¹¶å¯¹æ‰€æœ‰tæ±‚å’Œ

```c++
// æœ€å°å­—æ¯CHæ˜¯'a'ï¼Œå­—æ¯é›†å¤§å°Kæ˜¯26
template<char CH = 'a', int K = 26>
struct trie {
    struct node {
        array<int, K> child;
        int cnt[2]{0, 0};
        node () { memset(&child[0], -1, K * sizeof(int));}
    };

    vector<node> tr = {node()};

    trie(int tot_len = -1) {
        if (tot_len >= 0) tr.reserve(tot_len + 1);
    }

    int add(const string &s) {
        int p = 0; 
        for (char ch: s) {
            int u = ch - CH;
            if (tr[p].child[u] < 0) {
                tr[p].child[u] = int(tr.size());
                tr.emplace_back();
            }
            p = tr[p].child[u];
            tr[p].cnt[0]++;
        }
        tr[p].cnt[1]++;
        return p;
    }

    // prefix_of_s=1: trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²ç­‰äº s (å¦‚æœcount_prefix=1ï¼Œæ±‚å¤šå°‘ä¸ªå­—ç¬¦ä¸²æ˜¯sçš„å‰ç¼€)
    // prefix_of_s=0: sæ˜¯trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²çš„å‰ç¼€ (å¦‚æœcount_prefix=1ï¼Œå¯¹sçš„æ¯ä¸ªå‰ç¼€ä¹Ÿè¿›è¡Œç´¯åŠ )
    int get(const string &s, bool prefix_of_s = 0, bool count_prefix = 0) {
        int p = 0, ans = 0;
        for (char ch: s) {
            if (count_prefix) ans += tr[p].cnt[prefix_of_s];
            p = tr[p].child[ch - CH];
            if (p < 0) break;
        }
        if (p >= 0) ans += tr[p].cnt[prefix_of_s];
        return ans;
    }
};
```

**ä½¿ç”¨æ–¹æ³•**

å¦‚æœ s ä¸­å…¨ä¸ºå°å†™å­—æ¯ï¼Œå¯ä»¥å®šä¹‰ä¸º

`trie t` è€… `trie<'a', 26> t`

å¦‚æœæ—¢æœ‰å°å†™å­—æ¯åˆæœ‰å¤§å†™å­—æ¯ï¼Œåˆæœ‰æ•°å­—ï¼Œå…±62ç§å­—ç¬¦ï¼Œå¯ä»¥å»ºç«‹ä¸€ä¸ªå­—ç¬¦æ˜ å°„ï¼Œå¯¹æ¯ä¸ªå­—ç¬¦æ˜ å°„ä¸ºæ–°çš„å­—ç¬¦ï¼Œå†æ±‚è§£ã€‚

```c++
trie<0, 62> t;
auto get=[&](char c) {
    if (c >='a' && c <= 'z'){
        return c - 'a'; // 0 - 25
    }else if(c >= 'A' && c <= 'Z'){
        return c - 'A' + 26; // 26 - 51
    }
    return c - '0' + 52;  // 52 - 61
};
```

### å­—ç¬¦ä¸²ç»Ÿè®¡

[acwing 835](https://www.acwing.com/problem/content/837/)

ç»´æŠ¤ä¸€ä¸ªå­—ç¬¦ä¸²é›†åˆï¼Œæ”¯æŒä¸¤ç§æ“ä½œï¼š

- I x å‘é›†åˆä¸­æ’å…¥ä¸€ä¸ªå­—ç¬¦ä¸² xï¼›
- Q x è¯¢é—®ä¸€ä¸ªå­—ç¬¦ä¸²åœ¨é›†åˆä¸­å‡ºç°äº†å¤šå°‘æ¬¡ã€‚

å…±æœ‰ N ä¸ªæ“ä½œï¼Œè¾“å…¥çš„å­—ç¬¦ä¸²æ€»é•¿åº¦ä¸è¶…è¿‡ 1e5ï¼Œå­—ç¬¦ä¸²ä»…åŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚

```c++
#include<bits/stdc++.h>
using namespace std;

// æœ€å°å­—æ¯CHæ˜¯'a'ï¼Œå­—æ¯é›†å¤§å°Kæ˜¯26
template<char CH = 'a', int K = 26>
struct trie {
    struct node {
        array<int, K> child;
        int cnt[2]{0, 0};
        node () { memset(&child[0], -1, K * sizeof(int));}
    };

    vector<node> tr = {node()};

    trie(int tot_len = -1) {
        if (tot_len >= 0) tr.reserve(tot_len + 1);
    }

    int add(const string &s) {
        int p = 0; 
        for (char ch: s) {
            int u = ch - CH;
            if (tr[p].child[u] < 0) {
                tr[p].child[u] = int(tr.size());
                tr.emplace_back();
            }
            p = tr[p].child[u];
            tr[p].cnt[0]++;
        }
        tr[p].cnt[1]++;
        return p;
    }

    // prefix_of_s=1: trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²ç­‰äº s (å¦‚æœcount_prefix=1ï¼Œæ±‚å¤šå°‘ä¸ªå­—ç¬¦ä¸²æ˜¯sçš„å‰ç¼€)
    // prefix_of_s=0: sæ˜¯trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²çš„å‰ç¼€ (å¦‚æœcount_prefix=1ï¼Œå¯¹sçš„æ¯ä¸ªå‰ç¼€ä¹Ÿè¿›è¡Œç´¯åŠ )
    int get(const string &s, bool prefix_of_s = 0, bool count_prefix = 0) {
        int p = 0, ans = 0;
        for (char ch: s) {
            if (count_prefix) ans += tr[p].cnt[prefix_of_s];
            p = tr[p].child[ch - CH];
            if (p < 0) break;
        }
        if (p >= 0) ans += tr[p].cnt[prefix_of_s];
        return ans;
    }
};

int main() {
    int n;
    cin >> n;
    string s, x;
    trie t;
    for (int i = 0; i < n; ++i) {
         cin >> s >> x;
         if (s[0] == 'I') t.add(x);
         else cout<<t.get(x,1,0)<<"\n";
    }
}
```

### å­—ç¬¦ä¸²çš„å‰ç¼€åˆ†æ•°å’Œ

[leetcodeå‘¨èµ›311 T4](https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/)

ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ words ï¼Œè¯¥æ•°ç»„ç”± éç©º å­—ç¬¦ä¸²ç»„æˆ,
å®šä¹‰å­—ç¬¦ä¸² word çš„ åˆ†æ•° ç­‰äºä»¥ `word` ä½œä¸º å‰ç¼€ çš„ `words[i]` çš„æ•°ç›®ã€‚

è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ `answer` ï¼Œå…¶ä¸­ answer[i] æ˜¯ words[i] çš„æ¯ä¸ª**éç©ºå‰ç¼€çš„åˆ†æ•°æ€»å’Œ** ã€‚

+ 1 <= words.length <= 1000
+ 1 <= words[i].length <= 1000
+ words[i] ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

```c++

// æœ€å°å­—æ¯CHæ˜¯'a'ï¼Œå­—æ¯é›†å¤§å°Kæ˜¯26
template<char CH = 'a', int K = 26>
struct trie {
    struct node {
        array<int, K> child;
        int cnt[2]{0, 0};
        node () { memset(&child[0], -1, K * sizeof(int));}
    };

    vector<node> tr = {node()};

    trie(int tot_len = -1) {
        if (tot_len >= 0) tr.reserve(tot_len + 1);
    }

    int add(const string &s) {
        int p = 0; 
        for (char ch: s) {
            int u = ch - CH;
            if (tr[p].child[u] < 0) {
                tr[p].child[u] = int(tr.size());
                tr.emplace_back();
            }
            p = tr[p].child[u];
            tr[p].cnt[0]++;
        }
        tr[p].cnt[1]++;
        return p;
    }

    // prefix_of_s=1: trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²ç­‰äº s (å¦‚æœcount_prefix=1ï¼Œæ±‚å¤šå°‘ä¸ªå­—ç¬¦ä¸²æ˜¯sçš„å‰ç¼€)
    // prefix_of_s=0: sæ˜¯trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²çš„å‰ç¼€ (å¦‚æœcount_prefix=1ï¼Œå¯¹sçš„æ¯ä¸ªå‰ç¼€ä¹Ÿè¿›è¡Œç´¯åŠ )
    int get(const string &s, bool prefix_of_s = 0, bool count_prefix = 0) {
        int p = 0, ans = 0;
        for (char ch: s) {
            if (count_prefix) ans += tr[p].cnt[prefix_of_s];
            p = tr[p].child[ch - CH];
            if (p < 0) break;
        }
        if (p >= 0) ans += tr[p].cnt[prefix_of_s];
        return ans;
    }
};

class Solution {
public:
    vector<int> sumPrefixScores(vector<string>& a) {
        trie t;
        int n = a.size();
        vector<int> c(n);
        for(auto&x:a) t.add(x);
        for(int i=0;i<n;++i){
            c[i]+=t.get(a[i],0,1);
        }
        return c;
    }
};
```

### å­—å…¸æ ‘ç»Ÿè®¡å‰ç¼€

[æ´›è°· p8306](https://www.luogu.com.cn/problem/P8306)

ç»™å®šnä¸ªå­—ç¬¦ä¸²s[1],...s[n],å’Œ qæ¬¡è¯¢é—®, æ¯æ¬¡è¯¢é—®ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²tï¼Œæ±‚s[1],...,s[n]ä¸­æœ‰å¤šå°‘ä¸ªå­—ç¬¦ä¸²s
æ»¡è¶³ t æ˜¯ sçš„å‰ç¼€ã€‚

+ è¾“å…¥çš„å­—ç¬¦ä¸²åªå«å¤§å°å†™å­—æ¯å’Œæ•°å­—ï¼Œä¸”ä¸å«ç©ºä¸²ã€‚
+ 1 <= n,q <= 1e5, è¾“å…¥å­—ç¬¦ä¸²æ€»é•¿åº¦ä¸è¶…è¿‡3e6

```c++
#include<bits/stdc++.h>
using namespace std;
// æœ€å°å­—æ¯CHæ˜¯'a'ï¼Œå­—æ¯é›†å¤§å°Kæ˜¯26
template<char CH = 'a', int K = 26>
struct trie {
    struct node {
        array<int, K> child;
        int cnt[2]{0, 0};
        node () { memset(&child[0], -1, K * sizeof(int));}
    };

    vector<node> tr = {node()};

    trie(int tot_len = -1) {
        if (tot_len >= 0) tr.reserve(tot_len + 1);
    }

    int add(const string &s) {
        int p = 0; 
        for (char ch: s) {
            int u = ch - CH;
            if (tr[p].child[u] < 0) {
                tr[p].child[u] = int(tr.size());
                tr.emplace_back();
            }
            p = tr[p].child[u];
            tr[p].cnt[0]++;
        }
        tr[p].cnt[1]++;
        return p;
    }

    // prefix_of_s=1: trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²ç­‰äº s (å¦‚æœcount_prefix=1ï¼Œæ±‚å¤šå°‘ä¸ªå­—ç¬¦ä¸²æ˜¯sçš„å‰ç¼€)
    // prefix_of_s=0: sæ˜¯trieä¸­å¤šå°‘ä¸ªå­—ç¬¦ä¸²çš„å‰ç¼€ (å¦‚æœcount_prefix=1ï¼Œå¯¹sçš„æ¯ä¸ªå‰ç¼€ä¹Ÿè¿›è¡Œç´¯åŠ )
    int get(const string &s, bool prefix_of_s = 0, bool count_prefix = 0) {
        int p = 0, ans = 0;
        for (char ch: s) {
            if (count_prefix) ans += tr[p].cnt[prefix_of_s];
            p = tr[p].child[ch - CH];
            if (p < 0) break;
        }
        if (p >= 0) ans += tr[p].cnt[prefix_of_s];
        return ans;
    }
};

void solve() {

    int n, q;
    cin >> n >> q;
    trie<0, 62> t;

    auto get=[&](char c) {
        if(c>='a'&&c<='z'){
            return c-'a';
        }else if(c>='A'&&c<='Z'){
            return c-'A'+26;
        }
        return c-'0' + 52;
    };
    string s;

    for (int i = 0; i < n; ++i) {
        cin >> s;
        for(auto&x:s)x=get(x);
        t.add(s);
    }
    for (int i = 0; i < q; ++i) {
        cin >> s;
        for(auto&x:s)x=get(x);
        cout << t.get(s, 0, 0)<<"\n";
    }
}

int main(){
    int t; cin >> t;
    while(t--){
        solve();
    }
}
```

### kmpç®—æ³•

[acwing 831](https://www.acwing.com/problem/content/description/833/)

ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²så’Œt,æ±‚såœ¨tä¸­æ‰€æœ‰å‡ºç°ä½ç½®çš„ä¸‹æ ‡ã€‚

```c++
vector<int> kmp(string s, string t) {
    int n = s.size(), m = t.size();
    vector<int> nxt(n+1), res;
    for (int i = 1, j = 0; i < n; ++i) {
        while (j && s[i] != s[j]) j = nxt[j - 1];
        if (s[i] == s[j]) j++;
        nxt[i] = j;
    }
    for (int i = 0, j = 0; i < m; ++i) {
        while(j && t[i] != s[j]) j = nxt[j - 1];
        if (t[i] == s[j]) {
            j++;
            if (j == n) {
                res.push_back(i - n + 1);
                j = nxt[n - 1];
            }
        }
    }
    return res;
}
```

### zå‡½æ•°

å¯¹äºé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²sï¼Œå®šä¹‰å‡½æ•°z[i]è¡¨ç¤ºså’Œs[i,n-1]ï¼ˆå³ä»¥s[i]å¼€å¤´çš„åç¼€ï¼‰çš„æœ€é•¿å…¬å…±å‰ç¼€çš„é•¿åº¦ï¼Œzè¢«ç§°ä¸ºsçš„zå‡½æ•°ã€‚


[leetcode 2223](https://leetcode-cn.com/problems/sum-of-scores-of-built-strings/)


```c++
class Solution {
public:
    vector<int> z_function(string& s) {
        int n = s.size();
        vector<int> z(n, n);
        for (int i = 1, l = 0, r = 0; i < n; i += 1) {
            if (i <= r and z[i - l] < r - i + 1) z[i] = z[i - l];
            else for (z[i] = max(0, r - i + 1); i + z[i] < n && s[z[i]] == s[i + z[i]]; z[i] += 1);
            if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
        }
        return z;
    }
    long long sumScores(string s) {
        vector<int> z = z_function(s);
        long long c = 0;
        for(auto&x: z) c+=x;
        return c;
    }
};
```


## acè‡ªåŠ¨æœº

### ç®€å•ç‰ˆ

ç»™å®š n ä¸ªæ¨¡å¼ä¸² s[i] å’Œä¸€ä¸ªæ–‡æœ¬ä¸² tï¼Œæ±‚æœ‰å¤šå°‘ä¸ªä¸åŒçš„æ¨¡å¼ä¸²åœ¨æ–‡æœ¬ä¸²é‡Œå‡ºç°è¿‡ã€‚
ä¸¤ä¸ªæ¨¡å¼ä¸²ä¸åŒå½“ä¸”ä»…å½“ä»–ä»¬ç¼–å·ä¸åŒã€‚

[æ´›è°·p3808](https://www.luogu.com.cn/problem/P3808)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 6;
int n;

namespace AC {
int tr[N][26], tot;
int e[N], fail[N];

void insert(char *s) {
  int u = 0;
  for (int i = 1; s[i]; i++) {
    if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;  // å¦‚æœæ²¡æœ‰åˆ™æ’å…¥æ–°èŠ‚ç‚¹
    u = tr[u][s[i] - 'a'];                              // æœç´¢ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
  }
  e[u]++;  // å°¾ä¸ºèŠ‚ç‚¹ u çš„ä¸²çš„ä¸ªæ•°
}

queue<int> q;

void build() {
  for (int i = 0; i < 26; i++)
    if (tr[0][i]) q.push(tr[0][i]);
  while (q.size()) {
    int u = q.front();
    q.pop();
    for (int i = 0; i < 26; i++) {
      if (tr[u][i]) {
        fail[tr[u][i]] =
            tr[fail[u]][i];  // failæ•°ç»„ï¼šåŒä¸€å­—ç¬¦å¯ä»¥åŒ¹é…çš„å…¶ä»–ä½ç½®
        q.push(tr[u][i]);
      } else
        tr[u][i] = tr[fail[u]][i];
    }
  }
}

int query(char *t) {
  int u = 0, res = 0;
  for (int i = 1; t[i]; i++) {
    u = tr[u][t[i] - 'a'];  // è½¬ç§»
    for (int j = u; j && e[j] != -1; j = fail[j]) {
      res += e[j], e[j] = -1;
    }
  }
  return res;
}
}  // namespace AC

char s[N];

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) scanf("%s", s + 1), AC::insert(s);
  scanf("%s", s + 1);
  AC::build();
  printf("%d", AC::query(s));
  return 0;
}
```

### å¼ºåŒ–ç‰ˆ

æœ‰ N ä¸ªç”±å°å†™å­—æ¯ç»„æˆçš„æ¨¡å¼ä¸²ä»¥åŠä¸€ä¸ªæ–‡æœ¬ä¸² Tã€‚æ¯ä¸ªæ¨¡å¼ä¸²å¯èƒ½ä¼šåœ¨æ–‡æœ¬ä¸²ä¸­å‡ºç°å¤šæ¬¡ã€‚ä½ éœ€è¦æ‰¾å‡ºå“ªäº›æ¨¡å¼ä¸²åœ¨æ–‡æœ¬ä¸² T ä¸­å‡ºç°çš„æ¬¡æ•°æœ€å¤šã€‚

[æ´›è°·p2796](https://www.luogu.com.cn/problem/P3796)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 156, L = 1e6 + 6;

namespace AC {
const int SZ = N * 80;
int tot, tr[SZ][26];
int fail[SZ], idx[SZ], val[SZ];
int cnt[N];  // è®°å½•ç¬¬ i ä¸ªå­—ç¬¦ä¸²çš„å‡ºç°æ¬¡æ•°

void init() {
  memset(fail, 0, sizeof(fail));
  memset(tr, 0, sizeof(tr));
  memset(val, 0, sizeof(val));
  memset(cnt, 0, sizeof(cnt));
  memset(idx, 0, sizeof(idx));
  tot = 0;
}

void insert(char *s, int id) {  // id è¡¨ç¤ºåŸå§‹å­—ç¬¦ä¸²çš„ç¼–å·
  int u = 0;
  for (int i = 1; s[i]; i++) {
    if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;
    u = tr[u][s[i] - 'a'];  // è½¬ç§»
  }
  idx[u] = id;  // ä»¥ u ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²ç¼–å·ä¸º idx[u]
}

queue<int> q;

void build() {
  for (int i = 0; i < 26; i++)
    if (tr[0][i]) q.push(tr[0][i]);
  while (q.size()) {
    int u = q.front();
    q.pop();
    for (int i = 0; i < 26; i++) {
      if (tr[u][i]) {
        fail[tr[u][i]] =
            tr[fail[u]][i];  // failæ•°ç»„ï¼šåŒä¸€å­—ç¬¦å¯ä»¥åŒ¹é…çš„å…¶ä»–ä½ç½®
        q.push(tr[u][i]);
      } else
        tr[u][i] = tr[fail[u]][i];
    }
  }
}

int query(char *t) {  // è¿”å›æœ€å¤§çš„å‡ºç°æ¬¡æ•°
  int u = 0, res = 0;
  for (int i = 1; t[i]; i++) {
    u = tr[u][t[i] - 'a'];
    for (int j = u; j; j = fail[j]) val[j]++;
  }
  for (int i = 0; i <= tot; i++)
    if (idx[i]) res = max(res, val[i]), cnt[idx[i]] = val[i];
  return res;
}
}  // namespace AC

int n;
char s[N][100], t[L];

int main() {
  while (~scanf("%d", &n)) {
    if (n == 0) break;
    AC::init();  // æ•°ç»„æ¸…é›¶
    for (int i = 1; i <= n; i++)
      scanf("%s", s[i] + 1), AC::insert(s[i], i);  // éœ€è¦è®°å½•è¯¥å­—ç¬¦ä¸²çš„åºå·
    AC::build();
    scanf("%s", t + 1);
    int x = AC::query(t);
    printf("%d\n", x);
    for (int i = 1; i <= n; i++)
      if (AC::cnt[i] == x) printf("%s\n", s[i] + 1);
  }
  return 0;
}
```

## manacherç®—æ³•

ç»™å®šé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²sï¼Œæ‰¾å‡ºæ‰€æœ‰å¯¹(i,j)ï¼Œä½¿å¾—s[i,j]ä¸ºä¸€ä¸ªå›æ–‡ä¸²ã€‚

å¯¹äºæ¯ä¸ªä½ç½® i=0,1,...,n-1,æˆ‘ä»¬æ‰¾å‡ºå€¼d1[i]å’Œd2[i],äºŒè€…åˆ†åˆ«è¡¨ç¤ºä»¥ä½ç½® i ä¸ºä¸­å¿ƒçš„é•¿åº¦ä¸ºå¥‡æ•°å’Œé•¿åº¦ä¸ºå¶æ•°çš„å›æ–‡ä¸²ä¸ªæ•°, æ¢ä¸ªè§’åº¦ï¼ŒäºŒè€…ä¹Ÿè¡¨ç¤ºäº†ä»¥ä½ç½® i ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²çš„åŠå¾„é•¿åº¦ï¼ˆåŠå¾„é•¿åº¦ d1[i]ï¼Œd2[i] å‡ä¸ºä»ä½ç½® i åˆ°å›æ–‡ä¸²æœ€å³ç«¯ä½ç½®åŒ…å«çš„å­—ç¬¦ä¸ªæ•°ï¼‰ã€‚


```c++
void manacher(string s){
    int n = s.size();
    vector<int> d1(n), d2(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
        d1[i] = k--;
        if (i + k > r) l = i - k, r = i + k;
    }
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
        d2[i] = k--;
        if (i + k > r) l = i - k - 1, r = i + k;
    }
}
```
manacherç®—æ³•æ±‚å‡ºd1,d2åå¯åœ¨O(1)çš„æ—¶é—´å†…åˆ¤æ–­sçš„ä»»æ„åŒºé—´æ˜¯å¦æ˜¯å›æ–‡ä¸²,ä¾‹å¦‚

åˆ¤æ–­ `s[l],s[l+1],...s[r-1]`æ˜¯å¦æ˜¯å›æ–‡ä¸²

```c++
auto is_palindrome = [&](int l, int r) {
    if ((r - l) % 2 == 0)
        return d2[(l + r) / 2] >= (r - l) / 2;
    return d1[(l + r) / 2] >= (r - l + 1) / 2;
};
```


### æœ€é•¿å›æ–‡å­ä¸²

[lc5 æœ€é•¿å›æ–‡å­ä¸²](https://leetcode.cn/problems/longest-palindromic-substring/)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size()ï¼Œ mx = 0;
        vector<int> d1(n), d2(n);
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
            d1[i] = k--;
            if (i + k > r) l = i - k, r = i + k;
        }
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
            d2[i] = k--;
            if (i + k > r) l = i - k - 1, r = i + k;
        }

        for (int i = 0; i < n; ++i) 
            mx = max({mx, 2 * d1[i] - 1, 2 * d2[i]});

        for (int i = 0; i < n; ++i) 
            if (2 * d1[i] - 1 == mx) return s.substr(i - d1[i] + 1, mx);
            else if (2 * d2[i] == mx) return s.substr(i - d2[i], mx);
        return "";
    }
};
```

### å˜æˆå›æ–‡ä¸²æœ€å°‘åœ¨å‰é¢æ·»åŠ å­—ç¬¦æ•°

[geeksforgeeks](https://practice.geeksforgeeks.org/problems/minimum-characters-to-be-added-at-front-to-make-string-palindrome/1)

ç»™å®šå­—ç¬¦ä¸²sï¼Œåœ¨så‰é¢æœ€å°‘æ·»åŠ å¤šå°‘å­—ç¬¦ï¼Œèƒ½è®©så˜æˆå›æ–‡ä¸²ã€‚

+ 1 <= s.size() <= 1e6

**åˆ†æ** 

å‡è®¾åœ¨så‰é¢æ·»åŠ kä¸ªå­—ç¬¦èƒ½è®©så˜ä¸ºå›æ–‡ä¸²ï¼Œé‚£ä¹ˆè¯¥kä¸ªå­—ç¬¦ä¸sé•¿åº¦ä¸ºkçš„åç¼€æ„æˆå›æ–‡ä¸²ï¼Œä¸”sçš„ä¸­é—´éƒ¨åˆ†ä¹Ÿæ„æˆå›æ–‡ä¸²ã€‚

`s = "abacd", k = 2, ->   s = "dcabacd"`

```c++
int minChar(string s){
    int n = s.size();
    vector<int> d1(n), d2(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
        d1[i] = k--;
        if (i + k > r) l = i - k, r = i + k;
    }
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
        d2[i] = k--;
        if (i + k > r) l = i - k - 1, r = i + k;
    }
    
    // s[l], s[l+1],,,s[r - 1] is palindrome
    auto is_palindrome = [&](int l, int r) {
        if ((r - l) % 2 == 0)
            return d2[(l + r) / 2] >= (r - l) / 2;
        return d1[(l + r) / 2] >= (r - l + 1) / 2;
    };
    
    for(int i = 0; i < n; ++i) {
        if (is_palindrome(0, n - i)) return i;
    }
    return n;
}
```

### æ¯ä¸ªä½ç½®å¼€å§‹çš„å›æ–‡ä¸²æ•°ç›®

[ç‰›å®¢acmåŒæ­¥èµ›](https://ac.nowcoder.com/acm/contest/33540/A)

ç»™å‡ºä¸€ä¸ªåºåˆ— a, å¯¹äºiï¼Œæ±‚æ»¡è¶³å¦‚ä¸‹æ¡ä»¶çš„jçš„æ•°ç›®ã€‚
- i <= j
- a[i],...,a[j] æ˜¯ä¸€ä¸ªå›æ–‡ä¸²
- 1 <= n <= 1e6

**åˆ†æ**

manacherç®—æ³• ä¸­çš„ d1[i]å’Œd2[i],äºŒè€…åˆ†åˆ«è¡¨ç¤ºä»¥ä½ç½® i ä¸ºä¸­å¿ƒçš„é•¿åº¦ä¸ºå¥‡æ•°å’Œé•¿åº¦ä¸ºå¶æ•°çš„å›æ–‡ä¸²ä¸ªæ•°ï¼Œä¹Ÿè¡¨ç¤ºäº†ä»¥ä½ç½® i ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²çš„åŠå¾„é•¿åº¦

é‚£ä¹ˆå¯¹äºæ¯ä¸ªä¸­å¿ƒç‚¹jï¼Œåœ¨ [j+1-d1[j], j]ä¹‹é—´çš„æ¯ä¸ªiï¼Œjéƒ½æ»¡è¶³ä¸Šè¿°æ¡ä»¶ï¼Œä½¿ç”¨ å·®åˆ†æ•°ç»„ï¼Œå¯ä»¥åœ¨o(n)æ—¶é—´å†…
æ±‚å‡ºæ¯ä¸ªiæ»¡è¶³çš„jçš„æ•°ç›®ï¼Œç”±äºé•¿åº¦ä¸ºå¶æ•°å’Œå¥‡æ•°éƒ½ä¼šå°†jæœ¬èº«è®¡ç®—ä¸€éï¼Œæœ€åç»“æœéœ€è¦å‡å»1ã€‚

```c++
vector<int> cal(vector<int>& s) {
    int n = s.size(), sum = 0;
    vector<int> d1(n), d2(n), c(n), res(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
        d1[i] = k--;
        if (i + k > r) l = i - k, r = i + k;
    }
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
        d2[i] = k--;
        if (i + k > r) l = i - k - 1, r = i + k;
    }
    for (int i = 0; i < n; ++i) {
        c[i +1 - d1[i]]++, c[i + 1]--;
        c[i - d2[i]]++, c[i + 1]--;
    }
    for (int i = 0; i < n; ++i) {
        sum += c[i];
        res[i] = sum - 1;
    }
    return res;
}
```

### å‰åç¼€å›æ–‡ä¸²

[CF globalRound 7 D2](https://codeforces.com/contest/1326/problem/D2)

å­—ç¬¦ä¸²sç”±å°å†™å­—æ¯ç»„æˆï¼Œæ±‚ä¸€ä¸ªæœ€é•¿çš„å›æ–‡ä¸²tï¼Œæ»¡è¶³:

+ tçš„é•¿åº¦ä¸è¶…è¿‡s
+ å­˜åœ¨ä¸¤ä¸ªå­—ç¬¦ä¸²a,b ä½¿å¾— `t=a+b` ,å…¶ä¸­aæ˜¯sçš„å‰ç¼€å­—ç¬¦ä¸²ï¼Œbæ˜¯sçš„åç¼€å­—ç¬¦ä¸²
+ 1 <= s.size() <= 1e6

**åˆ†æ**

tå¯ä»¥è¡¨ç¤ºä¸º `s[1..l]+s[(n-r+1)..n]`ï¼Œ
é¦–å…ˆæ‰¾åˆ°ä¸€ä¸ªæœ€å¤§çš„kæ»¡è¶³ï¼Œ
`s[1]=s[n],s[2]=s[n-1],...,s[k]=s[n-k+1]`ï¼Œ
åœ¨æœ€ä¼˜è§£ä¸­ï¼Œä¸€å®šæ»¡è¶³ `min(l,r)=k`, 
æˆ‘ä»¬åªéœ€æ‰¾åˆ°ä¸€ä¸ªæœ€é•¿çš„å›æ–‡ä¸²w,wæ˜¯ğ‘ [(ğ‘˜+1)..(ğ‘›âˆ’ğ‘˜)]çš„å‰ç¼€æˆ–åç¼€ï¼Œ
é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ `s[1..k]+w+s[(n-k+1)..n]`


**æ–¹æ³•ä¸€ï¼šmanacher**

```c++
string prefix_suffix_palindrome(string &s) {
    int n = s.size();
    vector<int> d1(n), d2(n);
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
        d1[i] = k--;
        if (i + k > r) l = i - k, r = i + k;
    }
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
        d2[i] = k--;
        if (i + k > r) l = i - k - 1, r = i + k;
    }

    auto is_palindrome = [&](int l, int r) { // check s[l..(r-1)]
        if ((r - l) % 2 == 0) return d2[(l + r) / 2] >= (r - l) / 2;
        return d1[(l + r) / 2] >= (r - l + 1) / 2;
    };

    int l = -1, r = n, lmx = 0, rmx = 0;
    while (l + 2 < r && s[l + 1] == s[r - 1]) {
        l++, r--;
    } 

    for (int i = l + 1; i < r; ++i) {
        if (is_palindrome(l + 1, i + 1)) 
            lmx = max(lmx, i - l);
        if (is_palindrome(i, r)) 
            rmx = max(rmx, r - i);
    }

    string t = lmx > rmx ? s.substr(l + 1, lmx) : s.substr(r - rmx, rmx);

    return s.substr(0, l + 1) + t + s.substr(r ,l + 1);
}
```

**æ”¾å¤§äºŒï¼špalindromes_tree**

```c++
struct palindrome_tree{
    // ...
};
string prefix_suffix_palindrome(string &s) {
    int n = s.size(), l = -1, r = n;
    while (l + 2 < r && s[l + 1] == s[r - 1]) {
        l++, r--;
    } 

    string t1 = s.substr(l + 1, r - l - 1), t2 = t1;
    reverse(t2.begin(), t2.end());
    palindrome_tree<int> p1(t1), p2(t2);

    int lmx = p1[p1.longest_suffix()].len, lpos = p1[p1.longest_suffix()].pos;
    int rmx = p2[p2.longest_suffix()].len, rpos = p2[p2.longest_suffix()].pos;

    string t = lmx > rmx ? t1.substr(lpos, lmx) : t2.substr(rpos, rmx);

    return s.substr(0, l + 1) + t + s.substr(r ,l + 1);
}
```

## å›æ–‡è‡ªåŠ¨æœº

å›æ–‡è‡ªåŠ¨æœºï¼ˆPalindromes_Automatonï¼ŒPAMï¼‰ï¼Œä¹Ÿå«å›æ–‡æ ‘ï¼Œæ˜¯é«˜æ•ˆè§£å†³å›æ–‡é—®é¢˜çš„ç®—æ³•ï¼Œèƒ½å¤Ÿè§£å†³å¾ˆå¤šManacherç®—æ³•è§£å†³ä¸äº†çš„å›æ–‡é¢˜ã€‚å¯ä»¥è§£å†³å¦‚å›æ–‡ä¸²ä¸ªæ•°ã€æœ¬è´¨ä¸åŒå›æ–‡ä¸²ä¸ªæ•°ã€å‰ç¼€0-iå†…å›æ–‡ä¸²ä¸ªæ•°ã€æŸä¸‹æ ‡ç»“å°¾çš„å›æ–‡ä¸²ä¸ªæ•°ç­‰ã€‚

**æ¨¡æ¿**

```c++
template<typename T, int ALPHABET_SIZE = 26, char CH = 'a'>
struct palindrome_tree {
    // node that represents a palindromic substring
    struct node_t {
        T len, pos, cnt; // å›æ–‡å­ä¸²é•¿åº¦ã€é¦–æ¬¡å‡ºç°ä½ç½®ã€å‡ºç°æ¬¡æ•°
        T depth, suff;   // suff: node-index of largest palindromic suffix
        T next[ALPHABET_SIZE]; // "A".next['x'] --> "xAx"
    };

    vector<char> _str;    // string of letter ordinals (e.g. 'a' is 0)
    vector<node_t> _nodes;
    T _suff;             // node-index of the current longest palindromic suffix
    long long _total;    // å›æ–‡å­ä¸²æ€»æ•°ï¼Œå¯åˆ°n*nçº§åˆ«

    palindrome_tree() {_init();}

    palindrome_tree(string &s) {
        _init();
        add_all(s);
    }

    void _init() {
        _str.clear();  _nodes.resize(3);
        _nodes[1].len = -1, _nodes[1].suff = 1;
        _nodes[2].len = 0, _nodes[2].suff = 1;
        _suff = 2, _total = 0;
    }

    template<typename C>
    void reserve_more(C& c, size_t sz) {
        if (c.size() + sz <= c.capacity()) return;
        c.reserve(std::max(c.size() + sz, c.capacity() + c.capacity() / 2));
    }

    T add_all(string &s) {
        size_t len = s.size();
        reserve_more(_str, len), reserve_more(_nodes, len);
        T c = 0;
        for (auto &ch: s) c += add(ch);
        return c;
    }

    T add(char let) {
        let = let - CH;
        _str.push_back(let);
        T i = _find_suffix(_suff, let);
        _suff = _nodes[i].next[let];
        if (_suff != 0) {
            _nodes[_suff].cnt++, _total += _nodes[_suff].depth;
            return 0;
        }
        T suff2 = _find_suffix2(i, let);
        _suff = (T)_nodes.size();
        _nodes.push_back({});
        _nodes[_suff].len = _nodes[i].len + 2;
        _nodes[_suff].pos = (T)_str.size() - _nodes[_suff].len;
        _nodes[_suff].cnt = 1;
        _nodes[_suff].suff = suff2;
        _nodes[_suff].depth = _nodes[suff2].depth + 1;
        _nodes[i].next[let] = _suff;
        _total += _nodes[_suff].depth;
        return 1;
    }

    T _find_suffix2(T i, char let) {
        if (i == 1) return 2;
        i = _find_suffix(_nodes[i].suff, let);
        return _nodes[i].next[let];
    }

    T _find_suffix(T i, char let) {
        T sz = (T)_str.size();
        while (sz < _nodes[i].len + 2 || _str[sz - _nodes[i].len - 2] != let) {
            i = _nodes[i].suff;
        }
        return i;
    }

    // This should be called only once after all elements are added!
    void propagate() {
        for (T i = (T)_nodes.size() - 1; i >= 3; i--) {
            T suff = _nodes[i].suff;
            _nodes[suff].cnt += _nodes[i].cnt;
        }
    }

    // Returns the number of total palindromic substrings, counting their multiplicities.
    long long total() const { return _total;}

    // Returns the number of distinct palindromic substrings, each counted only once.
    T distinct() const { return (T)_nodes.size() - 3;}

    // Returns the index of the node representing the longest palindromic suffix.
    T longest_suffix() const { return _suff;}

    // Returns the <length, index> of longest Palindrome substrings
    array<T, 2> longest_palindrome() const {
        T longest = 0, index = 0;
        for (int i = 3; i < (T)_nodes.size(); ++i) 
            if (_nodes[i].len > longest) 
                longest = _nodes[i].len, index = _nodes[i].pos;
        return {longest, index};
        
    } 

    // Returns the number of nodes.
    T size() const { return (T)_nodes.size();}

    // Accesses node by its index.
    node_t& operator[] (T index) { return _nodes[index];}
};
```

**ä½¿ç”¨æ–¹æ³•**

+ å®šä¹‰ä¸€ä¸ªå›æ–‡æ ‘ `palindrome_tree<int> pt(s); æˆ–è€… palindrome_tree<int, 26, 'A'> pt(s);`
+ å­—ç¬¦ä¸²ä¸­æœ‰å¤šå°‘ä¸ªå›æ–‡å­å­—ç¬¦ä¸² `pt.total();`
+ å­—ç¬¦ä¸²çš„æœ€é•¿å›æ–‡å­ä¸² `auto [max_len, pos] = pt.longest_palindrome()`

### æ¯ä¸ªä½ç½®ç»“æŸçš„å›æ–‡ä¸²æ•°ç›®

[æ´›è°·p5496](https://www.luogu.com.cn/problem/P5496)

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sã€‚ä¿è¯æ¯ä¸ªå­—ç¬¦ä¸ºå°å†™å­—æ¯ã€‚å¯¹äº s çš„æ¯ä¸ªä½ç½®ï¼Œè¯·æ±‚å‡ºä»¥è¯¥ä½ç½®ç»“å°¾çš„å›æ–‡å­ä¸²ä¸ªæ•°ã€‚

è¿™ä¸ªå­—ç¬¦ä¸²è¢«è¿›è¡Œäº†åŠ å¯†ï¼Œé™¤äº†ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œå…¶ä»–å­—ç¬¦éƒ½éœ€è¦é€šè¿‡ä¸Šä¸€ä¸ªä½ç½®çš„ç­”æ¡ˆæ¥è§£å¯†ã€‚

å…·ä½“åœ°ï¼Œè‹¥ç¬¬ i ä¸ªä½ç½®çš„ç­”æ¡ˆæ˜¯ kï¼Œç¬¬ i+1 å­—ç¬¦è¯»å…¥æ—¶çš„ASCII ç ä¸ºcï¼Œåˆ™ç¬¬ i+1 ä¸ªå­—ç¬¦å®é™…çš„ASCII ç ä¸º (c-97+k)%26+97ã€‚æ‰€æœ‰å­—ç¬¦åœ¨åŠ å¯†å‰åéƒ½ä¸ºå°å†™å­—æ¯ã€‚

```c++
struct palindrome_tree{
    //...
};
int main(){
    string s;
    cin >> s;
    palindrome_tree<int> pt;
    int k = 0;
    for(auto&c : s){
        c = (c - 97 + k) % 26 + 97;
        pt.add(c);
        k = pt[pt._suff].depth;
        cout<< k << " ";
    }
}
```



### å­—ç¬¦ä¸²æœ€å°è¡¨ç¤º

å½“å­—ç¬¦ä¸² s ä¸­å¯ä»¥é€‰å®šä¸€ä¸ªä½ç½® i æ»¡è¶³
`s[i...n] + s[1...i-1] == T`
åˆ™ç§° s ä¸ T å¾ªç¯åŒæ„.

**æœ€å°è¡¨ç¤º**

å­—ç¬¦ä¸² s çš„æœ€å°è¡¨ç¤ºä¸ºä¸ s å¾ªç¯åŒæ„çš„æ‰€æœ‰å­—ç¬¦ä¸²ä¸­å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²

æœ€å°è¡¨ç¤ºçš„O(n)ç®—æ³•


```c++
string min_rep(string s){
    int k = 0, i = 0, j = 1, n = s.size();
    while (k < n && i < n && j < n) {
        if (s[(i + k) % n] == s[(j + k) % n]) k++;
        else {
            s[(i + k) % n] > s[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
            if (i == j) i++;
            k = 0;
        }
    }
    i = min(i, j);
    return s.substr(i)+s.substr(0,i);
}
```

### lyndonåˆ†è§£

**Lyndon ä¸²** : å¯¹äºå­—ç¬¦ä¸² sï¼Œå¦‚æœ s çš„å­—å…¸åºä¸¥æ ¼å°äº s çš„æ‰€æœ‰åç¼€çš„å­—å…¸åºï¼Œæˆ‘ä»¬ç§° s æ˜¯ **ç®€å•ä¸²** æˆ–è€… **Lyndon ä¸²**ã€‚

ä¾‹å¦‚ï¼š`a, ab, aab, abb, ababb, abcd` éƒ½æ˜¯ç®€å•ä¸²ã€‚


**ç»“è®º1**

å½“ä¸”ä»…å½“sçš„å­—å…¸åºä¸¥æ ¼å°äºå®ƒçš„æ‰€æœ‰éå¹³å‡¡(éç©ºä¸”ä¸åŒäºæœ¬èº«)å¾ªç¯åŒæ„ä¸²æ—¶ï¼Œsæ‰æ˜¯ç®€å•ä¸²ã€‚

**Lyndonåˆ†è§£**ï¼š ä¸²sçš„Lyndonåˆ†è§£è®°ä¸º s=w1w2... wkï¼Œå…¶ä¸­æ‰€æœ‰wiä¸ºç®€å•ä¸²ï¼Œå¹¶ä¸”ä»–ä»¬çš„å­—å…¸åºæŒ‰ç…§éä¸¥æ ¼å•å‡æ’åºï¼Œå³

`w1 >= w2 >= ..., >= wk`ã€‚è¿™æ ·çš„åˆ†è§£å­˜åœ¨ä¸”å”¯ä¸€ã€‚


**Duvalç®—æ³•**

Duvalå¯ä»¥åœ¨**O(n)**æ—¶é—´å†…æ±‚å‡ºä¸€ä¸ªä¸²çš„Lyndonåˆ†è§£ã€‚

```c++
vector<string> duval(string const& s) {
  int n = s.size(), i = 0;
  vector<string> factorization;
  while (i < n) {
    int j = i + 1, k = i;
    while (j < n && s[k] <= s[j]) {
      if (s[k] < s[j])
        k = i;
      else
        k++;
      j++;
    }
    while (i <= k) {
      factorization.push_back(s.substr(i, j - k));
      i += j - k;
    }
  }
  return factorization;
}
```

**æœ€å°è¡¨ç¤ºæ³•**

```c++
string min_cyclic_string(string s) {
  s += s;
  int n = s.size();
  int i = 0, ans = 0;
  while (i < n / 2) {
    ans = i;
    int j = i + 1, k = i;
    while (j < n && s[k] <= s[j]) {
      if (s[k] < s[j])
        k = i;
      else
        k++;
      j++;
    }
    while (i <= k) i += j - k;
  }
  return s.substr(ans, n / 2);
}
```

### å­ä¸²åˆ†å€¼å’Œ

å­ä¸²çš„ **åˆ†å€¼** å®šä¹‰ä¸ºå­—ç¬¦ä¸²ä¸­ä¸åŒå­—ç¬¦çš„æ•°é‡ã€‚
ä¾‹å¦‚ "abbca" åˆ†å€¼ä¸º3ï¼Œå› ä¸ºå…¶æœ‰3ä¸ªä¸åŒå­—ç¬¦ã€‚

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s, è¿”å›å…¶æ‰€æœ‰å­å­—ç¬¦ä¸²çš„æ€»åˆ†å€¼ã€‚

[leetcode å‘¨èµ›291 p4](https://leetcode.cn/contest/weekly-contest-291/problems/total-appeal-of-a-string/)


**åˆ†æ**

å¯¹äºä¸€ä¸ªé•¿åº¦ä¸ºnçš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬è€ƒè™‘å…¶æ‰€æœ‰å­ä¸²çš„ä¸ªæ•°ï¼Œå¯ä»¥è€ƒè™‘ä»¥ä¸‹åšæ³•ï¼Œ

è€ƒè™‘ç¬¬iä¸ªå­—ç¬¦ï¼Œå®ƒå’Œå‰é¢å­—ç¬¦åŠ èµ·æ¥é•¿åº¦ä¸ºx, å’Œåé¢å­—ç¬¦åŠ èµ·æ¥é•¿åº¦ä¸ºyï¼Œåˆ™åŒ…å«å­—ç¬¦içš„æ‰€æœ‰å­ä¸²æ•°ç›®æœ‰ `x * y`ä¸ª.

ä¾‹å¦‚å¯¹äº`abcd`, å…¶å­ä¸²ä¸ªæ•°ä¸º `1*4 + 2*3 + 3*2 + 4*1` ï¼Œ
é‚£ä¹ˆæˆ‘ä»¬è€ƒè™‘æ¯ä¸ªå­—ç¬¦åœ¨åŒ…å«å®ƒçš„æ‰€æœ‰å­ä¸²ï¼Œç„¶åå‡å»é‡å¤å³å¯ï¼Œä»€ä¹ˆæ ·çš„æ˜¯é‡å¤çš„å‘¢ï¼Ÿ æˆ‘ä»¬ä»å·¦å‘å³è€ƒè™‘æ¯ä¸ªå­—ç¬¦ï¼Œé‚£ä¹ˆå‰é¢ç¬¬ä¸€ä¸ªå’Œè¯¥å­—ç¬¦ç›¸åŒçš„å­—ç¬¦çš„å‰ç¼€å°±æ˜¯é‡å¤è®¡ç®—çš„ï¼Œæˆ‘ä»¬å‡å»è¿™æ®µå‰ç¼€é•¿åº¦å³å¯ã€‚

ä¾‹å¦‚ `XXXXabcaXXXX` å¯¹äºç¬¬ä¸€ä¸ªaæˆ‘ä»¬å¯ä»¥æ²¡æœ‰é¡¾è™‘çš„ç»Ÿè®¡ï¼ŒåŠ ä¸ŠåŒ…å«å®ƒçš„æ‰€æœ‰å­ä¸²å³å¯ï¼Œå¯¹äºç¬¬äºŒä¸ªaï¼Œæ˜¾ç„¶æˆ‘ä»¬ç»Ÿè®¡å…¶å‰ç¼€æ—¶å¯èƒ½åŒ…å«ç¬¬ä¸€ä¸ªaï¼Œè®¾ç¬¬ä¸€ä¸ªaçš„ä¸‹æ ‡ä¸ºzï¼Œä¸Šè¿°è®¡ç®—å­ä¸²çš„å…¬å¼åœ¨è¿™é‡Œå°±è¦è½¬åŒ–ä¸º `(x-z)*y` ã€‚

```c++
class Solution {
public:
    long long appealSum(string s) {
        long long c = 0, n = s.size();
        vector<long long> p(26, -1);
        for (int i = 0; i < n; ++i) {
            c += (i - p[s[i] - 'a']) * (n - i);
            p[s[i] - 'a'] = i;
        }
        return c;
    }
};
```

### å­ä¸²å”¯ä¸€å­—ç¬¦å’Œ

æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå‡½æ•° countUniqueChars(s) æ¥ç»Ÿè®¡å­—ç¬¦ä¸² s ä¸­çš„å”¯ä¸€å­—ç¬¦ï¼Œå¹¶è¿”å›å”¯ä¸€å­—ç¬¦çš„ä¸ªæ•°ã€‚

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œæˆ‘ä»¬éœ€è¦è¿”å› countUniqueChars(t) çš„æ€»å’Œï¼Œå…¶ä¸­ t æ˜¯ s çš„å­å­—ç¬¦ä¸²ã€‚æ³¨æ„ï¼ŒæŸäº›å­å­—ç¬¦ä¸²å¯èƒ½æ˜¯é‡å¤çš„ï¼Œä½†ä½ ç»Ÿè®¡æ—¶ä¹Ÿå¿…é¡»ç®—ä¸Šè¿™äº›é‡å¤çš„å­å­—ç¬¦ä¸²ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œä½ å¿…é¡»ç»Ÿè®¡ s çš„æ‰€æœ‰å­å­—ç¬¦ä¸²ä¸­çš„å”¯ä¸€å­—ç¬¦ï¼‰ã€‚

ç”±äºç­”æ¡ˆå¯èƒ½éå¸¸å¤§ï¼Œè¯·å°†ç»“æœ mod 10 ^ 9 + 7 åå†è¿”å›ã€‚

[lcå‘¨èµ›83 p4](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)

**åˆ†æ**

è€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼Œå¯¹äºsä¸­ä»»ä¸€ä¸ªå­—ç¬¦ `s[i]` ï¼Œs ä¸­æœ‰å¤šå°‘ä¸ªå­ä¸²åªåŒ…å«ä¸€ä¸ª `s[i]`ï¼Œ å‡è®¾æœ‰ä¸€æ®µå­ä¸²æ˜¯è¿™æ ·çš„ `aXXXXaXXXXXa` ï¼Œå…¶ä¸­xä¸ºä¸ç­‰äºaçš„å…¶ä»–å­—ç¬¦ï¼ŒåªåŒ…å«ä¸­é—´é‚£ä¸ªaçš„æ‰€æœ‰å­ä¸²å…±æœ‰ 5 * 6 = 30ä¸ªï¼Œå…¶ä¸­å¼€å§‹ä½ç½®å¯ä»¥ä¸º
`XXXXa`ä¸­çš„ä»»ä¸€ä¸ªï¼Œç»“æŸä½ç½®å¯ä»¥ä¸º `aXXXXX`ä¸­çš„ä»»ä¸€ä¸ªã€‚

æœ€åå¯¹äºæ¯ä¸ªå­—ç¬¦ cï¼Œå°†è®¡æ•°ç»“æœè¿›è¡Œç´¯åŠ ï¼Œå°±å¾—åˆ°äº†æœ€ç»ˆçš„ç­”æ¡ˆã€‚

```c++
class Solution {
public:
    int uniqueLetterString(string s) {
        int mod = 1e9 + 7, n = s.size(), ans = 0;
        for (int i = 0; i < n; ++i) {
            int j = i - 1, k = i + 1;
            while (j >= 0 && s[j] != s[i]) j--;
            while (k < n && s[k] != s[i]) k++;
            ans = (ans + (i - j) * (k - i)) % mod;
        }
        return ans;
    }
};
```

### æœ€å¤§æ³¢åŠ¨å­å­—ç¬¦ä¸²

[åŒå‘¨èµ›78T4](https://leetcode.cn/problems/substring-with-largest-variance/)

å­—ç¬¦ä¸²çš„**æ³¢åŠ¨**å®šä¹‰ä¸ºå­—ç¬¦ä¸²ä¸­**å‡ºç°æ¬¡æ•°æœ€å¤š**çš„å­—ç¬¦ä¸**å‡ºç°æ¬¡æ•°æœ€å°‘**çš„å­—ç¬¦æ¬¡æ•°ä¹‹å·®ã€‚

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²sï¼ŒåªåŒ…å«å°å†™å­—æ¯ï¼Œæ±‚sæ‰€æœ‰**å­å­—ç¬¦ä¸²**çš„**æœ€å¤§æ³¢åŠ¨å€¼**ã€‚

**åˆ†æ**

æšä¸¾å“ªä¸ªå­—ç¬¦æ˜¯å‡ºç°æœ€å¤šçš„ï¼ˆè®°ä¸º xï¼‰ï¼Œå“ªä¸ªå­—ç¬¦æ˜¯å‡ºç°æœ€å°‘çš„ï¼ˆè®°ä¸º yï¼‰ã€‚æŠŠå­—ç¬¦ä¸²ä¸­æ‰€æœ‰ x æ”¹æˆ 1ï¼Œæ‰€æœ‰ y æ”¹æˆ -1ï¼Œå…¶å®ƒçš„éƒ½æ”¹æˆ 0ã€‚é‚£ä¹ˆè¯¥åºåˆ—çš„æœ€å¤§éç©ºå­æ®µå’Œå°±æ˜¯ä»¥ x ä¸ºå‡ºç°æœ€å¤šå­—ç¬¦ï¼Œy ä¸ºå‡ºç°æœ€å°‘å­—ç¬¦çš„ç­”æ¡ˆã€‚

æ³¨æ„xå’Œyå¿…é¡»éƒ½å‡ºç°åœ¨å­ä¸²ä¸­ï¼Œä¸èƒ½å§åªæœ‰xçš„å­ä¸²ä½œä¸ºç­”æ¡ˆï¼Œã€‚
æˆ‘ä»¬å¯ä»¥ç”¨å˜é‡ d1 ç»´æŠ¤ xå’Œyçš„å‡ºç°æ¬¡æ•°ä¹‹å·®ï¼Œåˆå§‹å€¼ä¸º0.

åŒæ—¶ç”¨å¦ä¸€ä¸ªå˜é‡ d2 ç»´æŠ¤åœ¨åŒ…å«yæ˜¯çš„xå’Œyå‡ºç°æ¬¡æ•°ä¹‹å·®ï¼Œåˆå§‹ä¸ºè´Ÿæ— ç©·ã€‚å› ä¸ºè¿˜æ²¡æœ‰é‡åˆ°yã€‚éå†å­—ç¬¦ä¸²sï¼š

+ å½“é‡åˆ°xæ—¶ï¼Œ d1 å’Œ d2 å‡åŠ 1
+ å½“é‡åˆ°yæ—¶ï¼Œ d1 å‡1ï¼Œd1è®°å½•æ­¤æ—¶çš„ d1å€¼ï¼Œè‹¥ d1ä½è´Ÿï¼Œåˆ™å°†å…¶ç½®é›¶ã€‚


```c++
class Solution {
public:
    int largestVariance(string s) {
        int n = s.size(), ans = 0;
        for (char x = 'a'; x <= 'z'; ++x) {
            for (char y = 'a'; y <= 'z'; ++y) {
                if (x == y) continue;
                int d1 = 0, d2 = -n;
                for (auto c : s) {
                    if (c == x) d1++, d2++;
                    else if (c == y) {
                        d2 = -- d1;
                        d1 = max(d1, 0);
                    }
                    ans = max(ans, d2);
                }
            }
        }
        return ans;
    }
};
```

### ç»Ÿè®¡å­ä¸²

ç»™å®šé•¿åº¦ä¸ºnçš„01ä¸²åŠæ•´æ•°kï¼Œéœ€è¦å›ç­”qä¸ªè¯¢é—®ã€‚ç¬¬iä¸ªè¯¢é—®ä¸º[li,ri],

æ±‚s[l,r]ä¸­æœ‰å¤šå°‘å­ä¸²ï¼Œè¯¥å­ä¸²ä¸­æ²¡æœ‰å­—ç¬¦å‡ºç°æ¬¡æ•°è¶…è¿‡kæ¬¡ã€‚

+ 1 <= k <= n <= 1e5
+ 1 <= q <= 1e5
+ 1 <= l <= r <= n

**åˆ†æ**

è®¾ l[i] æ˜¯æœ€å¤§çš„ä¸‹æ ‡jï¼Œä½¿å¾— s[i,j] åŒ…å«è‡³å¤škä¸ª0å’Œkä¸ª1ã€‚

å¯¹äºä¸€ä¸ªæŸ¥è¯¢ [L,R]ã€‚ ä»¥ä¸‹æ ‡iå¼€å§‹çš„æœ‰æ•ˆstringå…±æœ‰ min(R,l[i]) - i + 1ã€‚

æ‰€ä»¥å¯¹äºæŸ¥è¯¢[L,R] çš„ç­”æ¡ˆä¸º

```
(l[i]-i+1) + ... + (l[k]-k+1) + (R-(k+1)+1) + ... + (R - R + 1)
```

å…¶ä¸­ k æ˜¯æ»¡è¶³ l[k] <= R çš„æœ€å¤§ä¸‹æ ‡ã€‚

æˆ‘ä»¬å¯ä»¥å¯¹äºæ¯ä¸€ä¸ªRï¼Œé¢„å¤„ç†å‡ºå¯¹åº”çš„kã€‚


+ æ—¶é—´å¤æ‚åº¦ O(n + q)

```c++
vector<long long> countSubString(string s, int k, vector<vector<int>> &q) {
    int n = s.size(), m = q.size();
    vector<int> l(n), r(n), cnt(2);
    for (int i = 0, j = 0; i < n; ++i) {
        while (j < n && cnt[s[j] - '0'] + 1 <= k) cnt[s[j++] - '0']++;
        l[i] = j - 1;
        cnt[s[i] - '0']--;
    }
    cnt = {0, 0};
    for (int i = n - 1, j = n - 1; ~i; --i) {
        while (j >= 0 && cnt[s[j] - '0'] + 1 <= k) cnt[s[j--] - '0']++;
        r[i] = j + 1;
        cnt[s[i] - '0']--;
    }
    vector<long long> p(n + 1), ans(m);
    for (int i = 0; i < n; ++i) 
        p[i + 1] = p[i] + l[i];

    for (int i = 0; i < m; ++i) {
        int x = q[i][0], y = q[i][1], t = r[y] - 1;
        if (x <= t) {
            ans[i] = p[t + 1] - p[x] + 1ll * (y - t) * y;
            ans[i] -= (x + y - 2ll) * (y - x + 1ll) / 2;
        } else {
            ans[i] = (y - x + 2ll) * (y - x + 1ll) / 2;
        }

    }
    return ans;
}
```

### æœ‰è¶£å­ä¸²è®¡æ•°

å­—ç¬¦ä¸²xæ˜¯æœ‰è¶£çš„ï¼Œå½“ä¸”ä»…å½“å®ƒæ»¡è¶³ä¸‹é¢çš„æ¡ä»¶ï¼š

+ x åŒ…å«è‡³å°‘ k ç§ä¸åŒå­—ç¬¦
+ x ä¸­ä»»æ„å­—ç¬¦å‡ºç°çš„æ¬¡æ•°ç›¸ç­‰

ç»™å®šå­—ç¬¦ä¸² Sï¼Œè¯·æ±‚å‡ºå®ƒæœ‰å¤šå°‘å­ä¸²æ˜¯æœ‰è¶£çš„ã€‚

+ 1 <= s.length <= 5000
+ s ä¸­åªåŒ…å«å°å†™å­—æ¯

**åˆ†æ**

å­ä¸²s[i,j]æ˜¯æœ‰è¶£çš„ï¼Œåªéœ€æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

+ å­ä¸² åŒ…å«è‡³å°‘ k ä¸­ä¸åŒå­—ç¬¦
+ å­ä¸²ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­—ç¬¦çš„å‡ºç°æ¬¡æ•°ä¸åŒ…å«çš„ä¸åŒå­—ç¬¦æ•°ä¹˜ç§¯ç­‰äºå­ä¸²é•¿åº¦


```c++
int countSubString(string &s, int k) {
    int n = s.size(), ans = 0;
    for (int i = 0; i < n; ++i) {
        map<int, int> mp;
        int mx = 0, cnt = 0;
        for (int j = i; ~j; --j) {
            mp[s[j]]++;
            mx = max(mx, mp[s[j]]);
            if (mx * (int)(mp.size()) == (i - j + 1) && (int)mp.size() >= k)
                ans++;
        }
    }
}
```

### ç»Ÿè®¡ä¸åŒå›æ–‡å­åºåˆ—

[leetcode 730](https://leetcode.cn/problems/count-different-palindromic-subsequences/)

å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè¿”å› s ä¸­ä¸åŒçš„éç©º å›æ–‡å­åºåˆ— ä¸ªæ•° ã€‚

+ 1 <= s.length <= 1000
+ s[i] ä»…åŒ…å« a,b,c,d

```c++
class Solution {
public:
    int countPalindromicSubsequences(string s) {
        int n = s.size(), P = 1e9 + 7;
        vector dp(n, vector<int>(n));
        for (int i = 0; i < n; ++i) 
            dp[i][i] = 1;
        for (int len = 2; len <= n; ++len) {
            for (int i = 0; i + len <= n; ++i) {
                int j = i + len - 1;
                if (s[i] == s[j]) {
                    int l = i + 1, r = j - 1;
                    while (l <= r && s[l] != s[i]) l++;
                    while (r >= l && s[r] != s[j]) r--;
                    if (l > r) 
                        dp[i][j] = (2 + dp[i + 1][j - 1] * 2) % P;
                    else if (l == r)
                        dp[i][j] = (1 + dp[i + 1][j - 1] * 2) % P;
                    else
                        dp[i][j] = (0LL + dp[i + 1][j - 1] * 2 - dp[l + 1][r - 1] + P) % P;
                } else {
                    dp[i][j] = (0LL + dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + P) % P;
                }
            }
        }
        return dp[0][n - 1];
    }
};
```