---
layout: post
title: æ‚é¢˜é€‰è®²
date: 2022-06-08
tags: ç®—æ³•ä¸“é¢˜  
---


===

Index
---
<!-- TOC -->

- [daimayuan](#daimayuan)
  - [å­ä¸²çš„æœ€å¤§å·®](#å­ä¸²çš„æœ€å¤§å·®)
  - [åŒºé—´ä¸­ä¸å¤§äºxçš„æ•°çš„æ•°ç›®](#åŒºé—´ä¸­ä¸å¤§äºxçš„æ•°çš„æ•°ç›®)
  - [æ ‘ä¸Šè·¯å¾„å¼‚æˆ–å’Œ](#æ ‘ä¸Šè·¯å¾„å¼‚æˆ–å’Œ)
  - [æœ€å°æˆ–å€¼ç”Ÿæˆæ ‘](#æœ€å°æˆ–å€¼ç”Ÿæˆæ ‘)
  - [ç»Ÿè®¡å­æ•°ç»„å’Œæ¨¡kç­‰äºå­æ•°ç»„é•¿åº¦çš„æ•°é‡](#ç»Ÿè®¡å­æ•°ç»„çš„æ•°é‡)
  - [å¼‚æˆ–åæœ€å°‘é€†åºå¯¹æ•°](#å¼‚æˆ–åæœ€å°‘é€†åºå¯¹æ•°)
  - [æ–¹å—æ¶ˆå¤±çš„æ“ä½œæ¬¡æ•°](#æ–¹å—æ¶ˆå¤±çš„æ“ä½œæ¬¡æ•°)
  - [å·¥ä½œå®‰æ’](#å·¥ä½œå®‰æ’)
  - [æ ‘ä¸Šä¸‰è§’å½¢æ•°](#æ ‘ä¸Šä¸‰è§’å½¢æ•°)
  - [ç¯ä¸Šåˆ†æ®µå’Œçš„æœ€å¤§å…¬çº¦æ•°](#ç¯ä¸Šåˆ†æ®µå’Œçš„æœ€å¤§å…¬çº¦æ•°)
  - [å­—å…¸åºæœ€å°](#å­—å…¸åºæœ€å°)
  - [å¥½åºåˆ—](#å¥½åºåˆ—)
  - [åŒºé—´å’Œ](#åŒºé—´å’Œ)
- [acwing/ç‰›å®¢](#acwing)
  - [å¹³å‡å€¼å¤§äºkçš„æœ€é•¿å­æ•°ç»„é•¿åº¦](#å¹³å‡å€¼å¤§äºkçš„æœ€é•¿å­æ•°ç»„é•¿åº¦)
  - [æ‰€æœ‰å­æ•°ç»„å¹³å‡æ•°ä¹‹å’Œ](#æ‰€æœ‰å­æ•°ç»„å¹³å‡æ•°ä¹‹å’Œ)
  - [å‡å€¼å¤§äºç­‰äºkçš„å­æ•°ç»„æ•°ç›®](#å‡å€¼å¤§äºç­‰äºkçš„å­æ•°ç»„æ•°ç›®)
  - [æ•°å¯¹](#æ•°å¯¹)
  
   
<!-- /TOC -->


## daimayuan

### å­ä¸²çš„æœ€å¤§å·®

å®šä¹‰åºåˆ—çš„æœ€å¤§å·®ä¸ºåºåˆ—ä¸­æœ€å¤§æ•°ä¸æœ€å°æ•°çš„å·®ã€‚æ¯”å¦‚ (3,1,4,5,6) çš„æœ€å¤§å·®ä¸º 6âˆ’1=5 , (2,2) çš„æœ€å¤§å·®ä¸º 2âˆ’2=0 ã€‚

å®šä¹‰ä¸€ä¸ªåºåˆ—çš„å­ä¸²ä¸ºè¯¥åºåˆ—ä¸­è¿ç»­çš„ä¸€æ®µåºåˆ—ã€‚

ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º ğ‘› çš„æ•°ç»„ ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›ï¼Œè¯·æ±‚å‡ºè¿™ä¸ªåºåˆ—çš„æ‰€æœ‰å­ä¸²çš„æœ€å¤§å·®ä¹‹å’Œã€‚

+ 1 â‰¤ ğ‘› â‰¤ 500000
+ 0 â‰¤ ğ‘ğ‘– â‰¤ 1e8

**åˆ†æ**

å­åºåˆ—çš„æœ€å¤§æ•°å’Œæœ€å°æ•°ç›¸äº’ç‹¬ç«‹ï¼Œåˆ†åˆ«è®¡ç®—åºåˆ—çš„æ‰€æœ‰å­ä¸²çš„æœ€å¤§å€¼å’Œå’Œæœ€å°å€¼å’Œï¼Œå†æ±‚å·®ã€‚

```c++
long long calc(vector<int> &a){
    int n = a.size();
    auto get = [&](function<bool(int,int)> f) -> long long {
        vector<int> left(n, -1),right(n, n);
        stack<int> sk;
        for (int i = 0; i < n; ++i) {
            while (!sk.empty() && f(a[sk.top()],a[i])) {
                right[sk.top()] = i;
                sk.pop();
            }
            if (!sk.empty()) left[i] = sk.top();
            sk.push(i);
        }
        long long s = 0;
        for (int i = 0; i < n; ++i) {
            s += 1ll * (i - left[i]) * (right[i] - i) * a[i];
        }
        return s;
    };

    return get([&](int x,int y){return x < y;}) - get([&](int x,int y){return x > y;});
}
```

### åŒºé—´ä¸­ä¸å¤§äºxçš„æ•°çš„æ•°ç›®

åœ¨ç»™å®š ğ‘ é•¿çš„æ•°ç»„ {ğ´} ä¸­è¿›è¡Œ ğ‘„ æ¬¡è¯¢é—® [ğ¿ğ‘–,ğ‘…ğ‘–] åŒºé—´ä¸­ä¸å¤§äº ğ»ğ‘– çš„å…ƒç´ ä¸ªæ•°ã€‚

+ 1 <= n <= 100000
+ 1 <= ai <= 1e9

**åˆ†æ**

æˆ‘ä»¬ç”¨æ ‘çŠ¶æ•°ç»„ç»´æŠ¤åŒºé—´å’Œï¼Œå°†æ•°ç»„ a å¸¦ç€ä¸‹æ ‡ï¼ŒæŒ‰ç…§å€¼å¤§å°ä»å°åˆ°å¤§æ’åºï¼Œå†å°†æ¯ä¸ªè¯¢é—®ï¼ŒæŒ‰ç…§ h å€¼ä»å°åˆ°å¤§æ’åºã€‚ç„¶åæˆ‘ä»¬éå†æ¯ä¸ªè¯¢é—®ï¼Œå¯¹äºå½“å‰çš„ hï¼Œå°†æ•°ç»„ a ä¸­å°äºç­‰äºçš„ h çš„æ•°çš„ä¸‹æ ‡ pos è¿›è¡Œ add(pos,1), è¿™ä¸ªè¯¢é—®çš„ç­”æ¡ˆå°±æ˜¯ ask(r)-ask(l-1);

```c++
vector<int> calc(vector<int>& a, vector<vector<int>>& qs) {
    int n = a.size(), m = qs.size();
    vector<int> ans(m), tr(n);

    auto add = [&](int c, int x) {
        for (; c <= n; c += c & -c) tr[c - 1] += x;
    };

    auto ask = [&](int c) {
        int s = 0;
        for (; c; c -= c & -c) s += tr[c - 1];
        return s;
    };

    vector<array<int,2>> v;
    vector<array<int,4>> q;
    for (int i = 0; i < n; ++i) 
        v.push_back({a[i], i + 1});
    for (int i = 0; i < m; ++i) 
        q.push_back({qs[i][0], qs[i][1], qs[i][2], i});
    sort(v.begin(), v.end(), [&](array<int,2> x, array<int,2> y){return x[0] < y[0];});
    sort(q.begin(), q.end(), [&](array<int,4> x, array<int,4> y){return x[2] < y[2];});

    for (int i = 0, j = 0; i < m; ++i) {
        while (j < n && v[j][0] <= q[i][2]) 
            add(v[j++][1], 1);
        ans[q[i][3]] = ask(q[i][1]) - ask(q[i][0] - 1);
    }
    return ans;
}
```

### æ ‘ä¸Šè·¯å¾„å¼‚æˆ–å’Œ

ç»™å‡º ğ‘› ä¸ªç‚¹çš„ä¸€æ£µæ ‘ï¼Œæ¯ä¸ªç‚¹æœ‰å„è‡ªçš„ç‚¹æƒï¼Œå¤šæ¬¡è¯¢é—®ä¸¤ä¸ªç‚¹ç®€å•è·¯å¾„æ‰€æ„æˆç‚¹é›†çš„å¼‚æˆ–å’Œã€‚

**è¾“å…¥æ ¼å¼**
ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•°å­— ğ‘› å’Œ ğ‘š , ğ‘› è¡¨ç¤ºç‚¹æ•°ï¼Œğ‘š è¡¨ç¤ºè¯¢é—®æ¬¡æ•° ã€‚

æ¥ä¸‹æ¥ä¸€è¡Œ ğ‘› ä¸ªæ•´æ•° ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› ï¼Œè¡¨ç¤ºæ¯ä¸ªç‚¹çš„ç‚¹æƒã€‚

æ¥ä¸‹æ¥ ğ‘›âˆ’1 è¡Œ , æ¯è¡Œä¸¤ä¸ªæ•´æ•° ğ‘¢,ğ‘£ ï¼Œè¡¨ç¤ºç‚¹ ğ‘¢ å’Œç‚¹ ğ‘£ ä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹ã€‚

å†æ¥ä¸‹æ¥ ğ‘š è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° ğ‘¢,ğ‘£ ï¼Œè¡¨ç¤ºè¯¢é—®ç‚¹ ğ‘¢ åˆ°ç‚¹ ğ‘£ çš„ç®€å•è·¯å¾„æ‰€æ„æˆç‚¹é›†çš„å¼‚æˆ–å’Œã€‚

**è¾“å‡ºæ ¼å¼**
è¾“å‡º ğ‘š è¡Œï¼Œå¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œè¾“å‡ºä¸€è¡Œã€‚


+ 1 <= n,m <= 200000
+ 1 <= ai <= 1e6

**åˆ†æ**

ç°æ±‚å‡ºæ¯ä¸ªç‚¹åˆ°è·ŸèŠ‚ç‚¹çš„è·¯å¾„å¼‚æˆ–å€¼ï¼Œåˆ™ä¸¤ä¸ªç‚¹çš„è·¯å¾„å¼‚æˆ–å€¼ç­‰äºä¸¤ä¸ªèŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„å¼‚æˆ–å€¼å¼‚æˆ–ä¸Šæœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

```c++
void solve(){
    cin >> n >> m;
    vector<int> a(n),sum(n);
    rd(a);
    LCA g(n);

    for(int i = 0; i < n-1; ++i){
        cin>>x>>y;
        x--,y--;
        g.add_edge(x,y);
    }

    function<void(int,int)> dfs=[&](int u, int fa){
        if(fa==-1) sum[u]=a[u];
        else sum[u]=sum[fa]^a[u];
        for (auto v : g.g[u]) {
            if (v != fa) {
                dfs(v, u);
            }
        }
    };
    dfs(0,-1);
    g.complete();

    while(m--){
        cin>>x>>y;
        x--,y--;
        int u=g.lca(x,y);
        int t=sum[x]^sum[y]^a[u];
        cout<<t<<"\n";
    }
}
```

**æ€è·¯2**

å¯ä»¥ç»Ÿè®¡è¯¥è·¯å¾„ä¸Šæ¯ä¸€ä½æœ‰å¤šå°‘ä¸ª1ï¼Œå¦‚æœæœ‰å¥‡æ•°ä¸ªï¼Œåˆ™å¼‚æˆ–å’Œä¸º1ï¼Œå¦åˆ™ä¸º0ï¼Œè¿™ç§æ–¹æ³•è¿˜å¯ä»¥æ‰©å±•åˆ°ä¸€å¹¶è§£å†³è·¯å¾„ä¸ï¼Œè·¯å¾„æˆ–é—®é¢˜ï¼Œä¾‹å¦‚å¯¹äºæˆ–é—®é¢˜ï¼Œå¦‚æœè·¯å¾„ä¸Šè¯¥ä½å­˜åœ¨1ï¼Œåˆ™ç»“æœçš„è¯¥ä½ä¸º1ï¼Œå¦åˆ™ä¸º0ï¼Œå¯¹äºä¸é—®é¢˜ï¼Œè·¯å¾„ä¸Šè¯¥ä½1çš„ä¸ªæ•°ç­‰äºè·¯å¾„ä¸Šå…ƒç´ ä¸ªæ•°ï¼Œåˆ™è¯¥ä½ä¸º1ï¼Œå¦åˆ™ä¸º0.

ç»´æŠ¤ s[u][i] è¡¨ç¤ºèŠ‚ç‚¹uçš„ç¬¬iä½åˆ°æ ¹ç»“ç‚¹ä¸€å…±æœ‰å¤šå°‘ä¸ª1.

åˆ™è·¯å¾„u,vä¸Šçš„ç¬¬iä½1çš„æ•°ç›®ä¸º (è®¾ t = lca(u, v))
`s[u][i]+s[v][i] - 2 * s[t][i] + ((a[t] & (1 << i)) ? 1 : 0)`

```c++
void solve(int tt) {
    cin >> n >> m;
    vector<int> a(n);
    for (auto &x : a) cin >> x;
    LCA g(n);
    for(int i=1;i<n;++i){
        cin>>x>>y;
        x--,y--;
        g.add_edge(x,y);
    }

    vector<vector<int>> s(n,vector<int>(20));
    function<void(int,int)> dfs = [&](int u,int fa) {
        if(fa==-1){
            for(int i=0;i<20;++i){
                if(a[u]&(1<<i)) s[u][i]=1;
                else s[u][i]=0;
            }
        }else{
            for(int i=0;i<20;++i)
                s[u][i]=s[fa][i]+((a[u]&(1<<i))?1:0);
        }
        for(auto v:g.adj[u]){
            if(v!=fa){
                dfs(v,u);
            }
        }

    };

    dfs(0,-1);
    g.build();
    while(m--){
        cin>>x>>y;
        x--,y--;
        int u=g.get_lca(x,y);
        int p=0;
        for(int i=0;i<20;++i){
            if((s[x][i]+s[y][i]-((a[u]&(1<<i))?1:0))%2==1)p=p|(1<<i);
        }
        cout<<p<<"\n";
    }
}
```

### æœ€å°æˆ–å€¼ç”Ÿæˆæ ‘

ç»™å‡ºğ‘›ä¸ªç‚¹ï¼Œ ğ‘šæ¡è¾¹çš„æ— å‘å›¾ï¼Œ æ¯æ¡è¾¹è¿æ¥ğ‘¢,ğ‘£ä¸¤ä¸ªç«¯ç‚¹ï¼Œè¾¹æƒä¸ºğ‘¤ï¼Œ æ±‚å›¾çš„ç”Ÿæˆæ ‘çš„æœ€å°ä»£ä»·ã€‚

åœ¨è¿™é“é¢˜ä¸­ï¼Œ æˆ‘ä»¬å®šä¹‰ä¸€æ£µç”Ÿæˆæ ‘çš„ä»£ä»·ä¸ºä»–æ‰€æœ‰è¾¹çš„è¾¹æƒæŒ‰ä½æˆ–å¾—åˆ°çš„å€¼ã€‚

+ 1 <= u,v <= 2e5
+ n - 1 <= m <= 4e5
+ 1 <= w <= 1e9

**åˆ†æ**

è´ªå¿ƒ + å¹¶æŸ¥é›†

ä»é«˜ä½åˆ°ä½ä½ï¼Œåˆ¤æ–­æŸä¸€ä½èƒ½å¦å–0,ä½¿ç”¨å¹¶æŸ¥é›†åˆ¤æ–­æ˜¯å¦æ˜¯ç”Ÿæˆæ ‘ã€‚

å‡è®¾æˆ‘ä»¬å‰é¢ç¡®å®šäº†è¿™äº›ä½æ„æˆçš„æ•°ä½resï¼Œä¸”å½“å‰æ˜¯ç¬¬k ä½ï¼Œæˆ‘ä»¬å‡è®¾å½“å‰ä½å–0 ï¼Œé‚£ä¹ˆä»€ä¹ˆæ ·çš„è¾¹ä¼šä¼šåœ¨æˆ‘ä»¬çš„ç­”æ¡ˆä¸­å‘¢ï¼Œé¦–å…ˆè¿™ä¸ªè¾¹è¾¹æƒvçš„ç¬¬kä½ä¸€å®šæ˜¯0 ï¼Œå¦åˆ™ä¸€æˆ–ä¼šä½¿è¿™ä¸€ä½ä½1ï¼Œç”±äºåé¢çš„ä½ä¸ç¡®å®šå› æ­¤åé¢å–ä»€ä¹ˆéƒ½è¡Œï¼Œä½†æ˜¯å‰é¢ä¸€å®šè¦ç¬¦åˆæˆ‘ä»¬å‰é¢çš„reså³è¿™æ¡è¾¹æˆ–å®Œresï¼Œç¬¬kä½ä¹‹å‰çš„ä½ç½®å’Œresä¸­åº”è¯¥ç›¸åŒï¼Œä¸åŒçš„è¯ä»£è¡¨è¿™æ¡è¾¹åœ¨å‰é¢è´ªå¿ƒçš„æ—¶å€™å°±å»é™¤äº†ï¼Œè¦åˆ¤æ®µèƒ½å¦ç”Ÿæˆæ ‘ï¼Œç›´æ¥åˆ¤æ–­æœ€åè¿™ä¸ªå›¾æ˜¯å¦è¿é€šå³å¯ã€‚


```c++
const int N = 2e5 + 5;

int f[N];
int find(int x) {
    return x == f[x] ? x : f[x] = find(f[x]);
}

int n,m,x,y,k,q,res;
void solve(){
    cin>>n>>m;
    vector<array<int, 3>> a(m);
    for(int i=0;i<m;++i){
        cin>>a[i][0]>>a[i][1]>>a[i][2];
        a[i]={x,y,k};
    }
    
    auto chk = [&](int k)->bool{
        iota(f+1,f+n+1,1);
        int x=res,cnt = 0;
        for(int i=0;i<m;++i){
            int t=(1<<k)-1;
            t&=a[i][2];
            t|=x;
            if((a[i][2]>>k&1)==0&&t==(x|a[i][2])) {
                f[find(a[i][0])]=find(a[i][1]);
            }
        }
        for (int i=1;i<=n;++i){
            if(i==f[i]) cnt++;
        }
        return cnt!=1;
    };
 
    for(int i=30;~i;--i){
        if(chk(i)) res |= (1 << i);
    }
    cout << res << "\n";
}
```

### ç»Ÿè®¡å­æ•°ç»„çš„æ•°é‡

ç»™å®šé•¿åº¦ä¸ºnçš„æ•°ç»„aå’Œk, å¦‚æœä¸€ä¸ªå­æ•°ç»„å’Œé™¤ä»¥kçš„ä½™æ•°æ­£å¥½ç­‰äºå­æ•°ç»„é•¿åº¦,åˆ™ç§°å…¶ä¸ºå¥½å­æ•°ç»„ï¼Œç»Ÿè®¡å¥½å­æ•°ç»„çš„æ•°é‡ã€‚

+ 1 <= n <= 2e5
+ 1 <= k, a[i] <= 1e9

**åˆ†æ**

+ æ˜¾ç„¶å­æ•°ç»„é•¿åº¦å°äºkï¼Œå› ä¸ºæ¨¡kçš„èŒƒå›´åœ¨[0,k-1]

æ ¹æ®æ¡ä»¶ï¼š

```
 (a[i] + a[i+1] + ,,, + a[j]) % k = j - i + 1
```

è®¾ s ä¸º a çš„å‰ç¼€å’Œæ•°ç»„ï¼Œåˆ™ä¸Šå¼å˜ä¸º:
    
```
(s[j] - s[i - 1]) % k = j - i + 1
```

å³ï¼š

```
(s[j] - j) % k = (s[i - 1] - (i - 1)) % k
```

ä½¿ç”¨mapç»Ÿè®¡å³å¯ï¼Œæ³¨æ„å­æ•°ç»„é•¿åº¦è¦å°äºkã€‚

```c++
long long countSubarrays(vector<int> &a, int k) {
    int n = a.size();
    vector<int> s(n + 1);
    map<int, int> cnt;

    for (int i = 0; i < n; ++i) {
        s[i + 1] = (s[i] + a[i]) % k;
    }
    long long ans = 0;
    for (int i = 0; i <= n; ++i) {
        if (i >= k) cnt[((s[i-k] - i)%k + k)%k]--;
        ans += cnt[((s[i] - i)%k + k)%k];
        cnt[((s[i] - i)%k + k)%k]++;
    }
    return ans;
}
```

### å¼‚æˆ–åæœ€å°‘é€†åºå¯¹æ•°

ç»™ä½ ä¸€ä¸ªæœ‰ ğ‘› ä¸ªéè´Ÿæ•´æ•°ç»„æˆçš„æ•°ç»„ ğ‘ ï¼Œä½ éœ€è¦é€‰æ‹©ä¸€ä¸ªéè´Ÿæ•´æ•° ğ‘¥ï¼Œå¯¹æ•°ç»„ ğ‘ çš„æ¯ä¸€ä¸ª ğ‘ğ‘– ä¸ ğ‘¥ è¿›è¡Œå¼‚æˆ–åå½¢æˆæ–°çš„æ•°ç»„ ğ‘ï¼Œè¦æ±‚ ğ‘ æ•°ç»„çš„é€†åºå¯¹ä¸ªæ•°æœ€å°ï¼Œå¦‚æœæœ‰å¤šä¸ª ğ‘¥ æ»¡è¶³æ¡ä»¶ï¼Œè¾“å‡ºæœ€å°çš„ ğ‘¥ã€‚

+ 1 <= n <= 3e5
+ 0 <= ai <= 1e9

**åˆ†æ**

æŒ‰ä½æ¥ç¡®å®šx çš„æ¯ä¸€ä½é€‰ä»€ä¹ˆï¼Œæ¯ä¸€ä½ä¹‹é—´éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œä»é«˜åˆ°ä½æšä¸¾æ¯ä¸€ä½ï¼Œå¦‚æœå½“å‰ä½å–1 ä¼šä½¿é€†åºå¯¹æ•°é‡å‡å°‘å°±å–1ï¼Œä»é«˜ä½åˆ°ä½ä½ä¾æ¬¡ç¡®å®šå³å¯

```c++
long long mergeSort(int l, int r, vector<int>& nums, vector<int>& tmp) {
    if (l >= r) return 0;
    int m = (l + r) / 2;
    long long res = mergeSort(l, m, nums, tmp) + mergeSort(m + 1, r, nums, tmp);
    int i = l, j = m + 1;
    for (int k = l; k <= r; k++) tmp[k] = nums[k];
    for (int k = l; k <= r; k++) {
        if (i == m + 1) nums[k] = tmp[j++];
        else if (j == r + 1 || tmp[i] <= tmp[j]) nums[k] = tmp[i++];
        else {
            nums[k] = tmp[j++];
            res += m - i + 1; //å¦‚æœæ˜¯a[i] >= a[j]ï¼Œtmp[i] <= tmp[j] æ”¹ä¸ºtmp[i] < tmp[j]
        }
    }
    return res;
}

long long reversePairs(vector<int>& nums) {
    vector<int> tmp(nums.size());
    return mergeSort(0, nums.size() - 1, nums, tmp);
}

void solve(){
    rd(n);
    vector<int> a(n), b;
    rd(a);
    b = a;
    long long mn=reversePairs(a),t;
    long long res=0;
    for(int k=30;~k;--k){
        res |= 1 << k;
        for (int i = 0; i < n; ++i) 
            a[i] = (b[i] ^ res);
        t = reversePairs(a);
        if (t < mn) {
            mn = t;
        } else res ^= 1 << k;
    }
    cout << mn << " " << res << "\n";
}
```

### æ–¹å—æ¶ˆå¤±çš„æ“ä½œæ¬¡æ•°

æœ‰ğ‘›å †æ–¹å—ï¼Œç¬¬ğ‘–å †æ–¹å—ç”±â„ğ‘–ä¸ªæ–¹å—å †ç§¯è€Œæˆã€‚å…·ä½“å¯ä»¥çœ‹æ ·ä¾‹ã€‚

æ¥ä¸‹æ¥æ‹†æ–¹å—ã€‚ä¸€ä¸ªæ–¹å—ç§°ä¸ºå†…éƒ¨æ–¹å—å½“ä¸”ä»…å½“ä»–çš„ä¸Šä¸‹å·¦å³éƒ½æ˜¯æ–¹å—æˆ–è€…æ˜¯åœ°é¢ã€‚å¦åˆ™æ–¹å—å°±æ˜¯è¾¹ç•Œæ–¹å—ã€‚æ¯ä¸€æ¬¡æ“ä½œéƒ½è¦æŠŠè¾¹ç•Œæ–¹å—æ‹¿æ‰ã€‚

é—®å¤šå°‘æ¬¡æ“ä½œä¹‹åæ‰€æœ‰æ–¹å—ä¼šæ¶ˆå¤±ã€‚

<br />
![](/images/posts/leetcode/daimayuan_1.png)
<br />

+ 1 <= n <+ 1e5
+ 1 <= hi <= 1e9

**åˆ†æ**

æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œæ“ä½œæœ€å¤šæ‰§è¡Œ n/2æ¬¡ ï¼Œå› ä¸ºæ¯ä¸€æ¬¡æ‰§è¡Œæ“ä½œï¼Œéƒ½ä¼šæ¶ˆå»ä¸¤è¾¹çš„æ–¹å—ã€‚
æˆ‘ä»¬å¯ä»¥è®¨è®ºï¼Œä¸€ä¸ªæ–¹å—æ˜¯å› ä¸ºå˜æˆäº†ä¸¤è¾¹è¢«æ¶ˆå»ï¼Œè¿˜æ˜¯è‡ªå·±æ¶ˆå»äº†ã€‚

å¯¹äºä¸­é—´çš„æ–¹å—ï¼Œå¦‚æœå·¦å³çš„æ–¹å—è¶³å¤Ÿçš„å¤šï¼Œé‚£ä¹ˆæœ€å¤š h[i]æ¬¡æ“ä½œåï¼Œè¿™ä¸ªæ–¹å—å°±æ¶ˆå»äº†ã€‚

å¦‚æœä¸€ä¸ªæ–¹å—è¢«æ¶ˆå»äº†åï¼Œä¸‹ä¸€æ­¥ï¼Œå®ƒæ—è¾¹çš„ä¸¤ä¸ªæ–¹å—ä¹Ÿä¼šè¢«æ¶ˆå»ã€‚

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è€ƒè™‘è®°å½•æ¯ä¸ªæ–¹å—æ˜¯è¢«å·¦è¾¹çš„æ–¹å—æ¶ˆå»ï¼Œè¿˜æ˜¯å³è¾¹çš„æ–¹å—æ¶ˆå»ï¼Œè¿˜æ˜¯è‡ªå·±æ¶ˆå»äº†ã€‚

dp1[i] è¡¨ç¤ºè€ƒè™‘å·¦è¾¹ï¼Œç¬¬ iä¸ªæ–¹å—åœ¨ dp1[i] æ¬¡æ“ä½œåè¢«æ¶ˆå»ã€‚

è½¬ç§»ä¸º dp1[i]=min(dp1[i-1]+1,a[i]) ã€‚

å³è¾¹åŒç†ï¼Œå–ä¸ª min å°±æ˜¯ç¬¬ i ä¸ªæ–¹å—æ¶ˆå»çš„æ“ä½œæ•°ã€‚

æœ€åè®°å½•ä¸‹å¯ä»¥åšæŒæœ€é•¿æ—¶é—´çš„é‚£ä¸ªæ–¹å—ã€‚


```c++
int calc(vector<int> &a) {
    int n = a.size(), ans = 0;
    vector<int> dp1(n + 1), dp2(n + 1);
    for (int i = 0; i < n; ++i) dp1[i + 1] = min(dp1[i] + 1, a[i]);
    for (int i = n - 1; ~i; --i) dp2[i] = min(dp2[i + 1] + 1, a[i]);
    for (int i = 0; i < n; ++i) ans = max(ans, min(dp1[i + 1], dp2[i]));
    return ans;
}
```

### å·¥ä½œå®‰æ’

æœ‰né¡¹å·¥ä½œï¼Œæ¯é¡¹å·¥ä½œè¯è´¹ä¸€ä¸ªå•ä½æ—¶é—´ï¼Œä»æ—¶åˆ»0å¼€å§‹ï¼Œä½ æ¯ä¸ªæ—¶åˆ»å¯ä»¥é€‰æ‹©1-né¡¹å·¥ä½œçš„ä»»æ„ä¸€é¡¹å·¥ä½œå®Œæˆã€‚
æ¯é¡¹å·¥ä½œæœ‰ä¸€ä¸ªæˆªæ­¢æ—¥æœŸdi, å®Œæˆè¯¥å·¥ä½œå¯ä»¥è·å¾—åˆ©æ¶¦piï¼Œåœ¨ç»™å®šå·¥ä½œåˆ©æ¶¦å’Œæˆªæ­¢æ—¶é—´ä¸‹ï¼Œèƒ½è·å¾—çš„æœ€å¤§åˆ©æ¶¦æ˜¯å¤šå°‘ã€‚

+ 1 <= n <= 1e5
+ 0 <= di, pi <= 1e9

**åæ‚”è´ªå¿ƒ**

å› ä¸ºæˆ‘ä»¬çš„å·¥ä½œçš„æ—¶é—´éƒ½ä¸º 1 ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥è´ªå¿ƒã€‚ç”¨ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤ã€‚

åªè¦å¯ä»¥æ”¾ï¼Œå°±æ”¾ï¼Œå¦‚æœæ”¾ä¸äº†ï¼Œå°±æ‹¿å‡ºåˆ©æ¶¦æœ€å°çš„é‚£ä¸ªï¼Œæ¯”è¾ƒæœ€å°çš„è¿™ä¸ªå’Œå½“å‰å·¥ä½œçš„åˆ©æ¶¦ã€‚

æœ€åæˆ‘ä»¬ä¼˜å…ˆé˜Ÿåˆ—é‡Œé¢çš„ï¼Œå°±æ˜¯æˆ‘ä»¬æ‰€é€‰æ‹©çš„å·¥ä½œ

```c++
/*
a[i][0]: æˆªæ­¢æ—¶é—´ï¼Œ a[i][1]ï¼šåˆ©æ¶¦   
*/
long long maxProfit(vector<vector<int>> &a) {
    sort(all(a),[&](auto x, auto y){return x[0] < y[0];});
    priority_queue<int, vector<int>, greater<int>> q;
    for (int i = 0; i < (int)a.size(); ++i) {
        if (a[i][0] <= 0) continue;
        if (a[i][0] > q.size()) q.push(a[i][1]);
        else if (a[i][1] > q.top()) {
            q.pop();
            q.push(a[i][1]);
        }
    }
    long long ans = 0;
    while (q.size()) {
        ans += q.top(); q.pop();
    }
    return ans;
}
```

### æ ‘ä¸Šä¸‰è§’å½¢æ•°

ç»™ä¸€ä¸ªğ‘›ä¸ªèŠ‚ç‚¹çš„æ ‘, ä¸‰è§’æœå®šä¹‰ä¸ºä¸€ä¸ªåŒ…å«3ä¸ªèŠ‚ç‚¹çš„é›†åˆ, ä¸”ä»–ä»¬ä¸¤ä¸¤ä¹‹é—´çš„æœ€çŸ­è·¯é•¿åº¦ğ‘, ğ‘, ğ‘èƒ½å¤Ÿæ„æˆä¸€ä¸ªä¸‰è§’å½¢ã€‚

è®¡ç®—è¿™æ£µæ ‘ä¸Šæœ‰å¤šå°‘ä¸ªä¸åŒçš„ä¸‰è§’æœ

+ 1 <= n <= 1e5
+ 1 <= w <= 1e5
+ 1 <= u, v <= n

**1:æ ‘å½¢DP**

+ å½“ä¸‰ä¸ªç‚¹åœ¨æ ‘çš„ä¸€æ¡è·¯å¾„ä¸Šæ— è§£ï¼Œå…¶ä»–æƒ…å†µå‡æœ‰è§£.
+ ç”±äºä¸åœ¨ä¸€æ¡è·¯å¾„ä¸Šå› æ­¤å¿…ç„¶å­˜åœ¨ä¸€ä¸ªä¸­é—´ç»“ç‚¹åˆ†åˆ«ä¸è¿™äº›ç‚¹ç›¸è¿ï¼Œå‡è®¾è¿™ä¸ªç‚¹å’Œå…¶ä»–ä¸‰ä¸ªç‚¹ç›¸è¿çš„è¾¹æƒåˆ†åˆ«a,b,cï¼Œåˆ™a+b+b+c>a+cè¯æ˜ä¸æƒå€¼è·¯å¾„æƒå€¼æ— å…³äº†ã€‚

ä»¥ç‚¹u ä¸ºä¸­é—´ç‚¹çš„æ–¹æ¡ˆæ•°ï¼Œè¿™æ ·çš„æ–¹æ¡ˆæ•°ç”±ä¸¤éƒ¨åˆ†æ„æˆï¼š

+ u çš„ä¸¤ä¸ªä¸åŒçš„å­æ ‘å„é€‰ä¸€ä¸ªï¼Œéu çš„å­æ ‘é‡Œé€‰ä¸€ä¸ªè¿™æ ·æ˜¯ä¸ä¼šæ„æˆä¸€æ¡è·¯å¾„çš„
+ u çš„ä¸‰ä¸ªä¸åŒçš„å­æ ‘å„é€‰ä¸€ä¸ªï¼Œè¿™æ ·ä¹Ÿä¸ä¼šæ„æˆä¸€æ¡è·¯å¾„

**è®¡ç®—ç´¯ä¹˜å’Œ**

1. ç»™å®šæ•°ç»„aï¼Œè®¡ç®—(å¦‚ä¸‹ä¸¤ä¸ªå‡½æ•°å‡å¯)

<br />
![](/images/posts/leetcode/daimayuan_2.png)
<br />

```c++
long long cal1(vector<long long> &a) {
    long long  s1 = 0, s2 = 0;
    for (auto v : a) s1 += v, s2 += v * v;
    return (s1 * s1 - s2) / 2;
}

long long cal2(vector<long long> &a) {
    long long s1 = 0, s2 = 0;
    for (auto &x: a) {
        s1 = s1 + s2 * x;
        s2 += x;
    }
    return s1;
}
```

2. ç»™å®šæ•°ç»„aï¼Œè®¡ç®—(å¦‚ä¸‹ä¸¤ä¸ªå‡½æ•°å‡å¯)

<br />
![](/images/posts/leetcode/daimayuan_3.png)
<br />

```c++
long long fun1(vector<long long> &a) {
    long long  s1 = 0, s2 = 0, s3 = 0;
    for (auto v : a) s3 += v;
    for (auto v : a) s1 += 1ll * v * v * v, s2 += 3ll * v * v * (s3 - v);

    return (s3 * s3 * s3 - s1 - s2) / 6;
}

long long fun2(vector<long long> &a) {
    long long s1 = 0, s2 = 0, s3 = 0;
    for (auto &x: a) {
        s3 = s3 + s2 * x;
        s2 = s2 + s1 * x;
        s1 = s1 + x;
    }
    return s3;
}
```


```c++
long long cal1(vector<long long> &a) {
    long long  s1 = 0, s2 = 0;
    for (auto v : a) s1 += v, s2 += v * v;
    return (s1 * s1 - s2) / 2;
}
long long cal2(vector<long long>&a) {
    long long  s1 = 0, s2 = 0, s3 = 0;
    for (auto v : a) s3 += v;
    for (auto v : a) s1 += 1ll * v * v * v, s2 += 3ll * v * v * (s3 - v);

    return (s3 * s3 * s3 - s1 - s2) / 6;
}
void solve(){
    cin>>n;
    vector<vector<int>> g(n);
    f0(n-1){
        rd(x,y,k);
        x--,y--;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    long long c=0;
    vector<long long> s(n);
    function<void(int,int)> dfs=[&](int u,int fa){
        s[u]=1;
        vector<long long> a;
        for(auto&v:g[u]){
            if(v!=fa){
                dfs(v,u);
                a.push_back(s[v]);
                s[u]+=s[v];
            }
        }
        int m=a.size();
        if(m>=2) c+=cal1(a) * (n-s[u]);
        if(m>=3) c+=cal2(a);
    };
    dfs(0,-1);
    wt(c,'\n');
}
```

**æ•°å­¦**

å¦‚æœå°†å½“å‰ç‚¹u å»é™¤æ‰æˆ‘ä»¬å¯ä»¥å¾—åˆ°å¥½å‡ é¢—å­æ ‘ï¼Œé—®é¢˜è½¬åŒ–ä¸ºä»è¿™äº›æ ‘ä¸­é€‰ä¸‰æ£µæ ‘æ¯ä¸ªæ¯æ£µæ ‘é€‰ä¸€ä¸ªç»“ç‚¹,è®¾æ¯ä¸ªæ ‘çš„èŠ‚ç‚¹æ•°ä¸ºs[i], ä¹Ÿå°±æ˜¯æˆ‘ä»¬å¯ä»¥æšä¸¾å…¶ä¸­ä¸€ä¸ªç‚¹ï¼Œç„¶åä¿è¯è¿™ä¸ªç‚¹å‰é¢çš„é€’å¢ï¼Œåé¢çš„é€’å‡å³å¯ï¼Œä¹Ÿå°±æ˜¯ç­‰ä»·äºæˆ‘ä»¬æ±‚åˆ°äº†u è¿™ä¸ªç‚¹å¯¹äºå·²ç»å‡ºç°çš„ç‚¹ä½œä¸ºå·¦åŠéƒ¨åˆ†ï¼Œå½“å‰æšä¸¾çš„ä½œä¸ºuï¼Œæœªæšä¸¾åˆ°çš„ä½œä¸ºå³åŠéƒ¨åˆ†ï¼Œå› æ­¤å°±å¯ä»¥O(n)çš„æ±‚äº†ã€‚

```c++
vector<long long > s(n);
long long c = 0;
function<void(int,int)> dfs=[&](int u,int fa){
    s[u]=1;
    for(auto&v:g[u]){
        if(v!=fa){
            dfs(v,u);
            c += (s[u] - 1) * s[v] * (n - s[u] - s[v]);
            s[u] += s[v];
        }
    }
    
};
dfs(0,-1);
```

### ç¯ä¸Šåˆ†æ®µå’Œçš„æœ€å¤§å…¬çº¦æ•°

ç¯ä¸Šæœ‰ğ‘›ä¸ªæ­£æ•´æ•°ã€‚ä½ èƒ½å°†ç¯åˆ‡æˆğ‘˜æ®µï¼Œæ¯æ®µåŒ…å«ä¸€ä¸ªæˆ–è€…å¤šä¸ªæ•°å­—ã€‚

å¯¹äºä¸€ä¸ªåˆ‡åˆ†æ–¹æ¡ˆï¼Œä¼˜ç¾ç¨‹åº¦ä¸ºæ¯æ®µæ•°å­—å’Œçš„æœ€å¤§å…¬çº¦æ•°ï¼Œä½ æƒ³ä½¿åˆ‡åˆ†æ–¹æ¡ˆçš„ä¼˜ç¾ç¨‹åº¦æœ€å¤§ï¼Œå¯¹äºğ‘˜=1,2,â€¦,ğ‘›è¾“å‡ºç­”æ¡ˆã€‚

+ 1 <= n <= 2000
+ 1 <= a[i] <= 5e7

**åˆ†æ**

+ g ä¸ºæ•°ç»„æ€»å’Œçš„å› å­ï¼Œå¯ä»¥æšä¸¾ sum çš„å› å­ã€‚
+ å¦‚æœä¸€ä¸ªå› å­å¯ä»¥æ˜¯åˆ‡æˆkæ®µçš„ç»“æœï¼Œé‚£ä¹ˆå®ƒä¹Ÿå¯ä»¥æ˜¯åˆ‡æˆk-1æ®µçš„ç»“æœ



```c++
vector<long long> maxKsegmentGCD(vector<int> &a) {
    int n = a.size();
    vector<long long> s(n + 1), ans(n);
    for (int i = 0; i < n; ++i) {
        s[i + 1] = s[i] + a[i];
    }

    auto cal = [&](long long x) {
        map<long long, int> mp;
        int cot = 0;
        for (int i = 1; i <= n; i++) {
            mp[s[i] % x]++;
            cot = max(cot, mp[s[i] % x]);
        }
        ans[cot - 1] = max(ans[cot - 1], x);
    };
    int sq = sqrt(s[n]);
    for (int i = 1; i <= sq; ++i) {
        if (s[n] % i == 0) {
            cal(i);
            cal(s[n] / i);
        }
    }
    for (int i = n - 2; ~i; --i) {
        ans[i] = max(ans[i + 1], ans[i]);
    }
    return ans;
}
```

### å­—å…¸åºæœ€å°

ä»åºåˆ— ğ‘€ ä¸ªæ•°ä¸­é¡ºåºé€‰å‡º ğ‘ ä¸ªä¸åŒçš„æ•°, ä½¿å¾—è¿™ ğ‘ ä¸ªæ•°çš„å­—å…¸åºæœ€å°ã€‚
å…¶ä¸­ 1â‰¤ğ‘ğ‘–â‰¤ğ‘, æ•°æ®ä¿è¯ [1,ğ‘] èŒƒå›´å†…æ¯ä¸ªæ•°è‡³å°‘å‡ºç°ä¸€æ¬¡ã€‚

è®©ä½ æ‰¾ä¸€ä¸ªå­åºåˆ—ï¼Œä¸º N çš„æ’åˆ—ï¼Œä½¿å¾—å­—å…¸åºæœ€å°ï¼Œä¿è¯è‡³å°‘å­˜åœ¨ä¸€ä¸ªæ’åˆ—

+ 1 < n <= m <= 1e6

**å•è°ƒæ ˆ**

é¡ºåºæšä¸¾ï¼Œå¯¹äºa[i],å¦‚æœa[i]å·²ç»åœ¨æ ˆä¸­ï¼Œä¸åšå¤„ç†ï¼Œå¦åˆ™ï¼Œæˆ‘ä»¬å¼¹å‡ºæ‰€æœ‰å¤§äºa[i]çš„æ•°ï¼Œæ¥ä¿è¯å­—å…¸åºæœ€å°
ä½†éœ€è¦æ³¨æ„ï¼Œå¼¹å‡ºçš„æ•°éœ€è¦ä¿è¯åé¢è¿˜æœ‰è¿™ä¸ªæ•°ï¼Œä¸ç„¶çš„è¯å°±ä¸æ»¡è¶³æ¯ä¸ªæ•°éƒ½å‡ºç°ä¸€æ¬¡äº†ã€‚

```c++
/*
0 <= a[i] <= n - 1
*/
vector<int> minLexicographicalPerm(vector<int> &a, int n) {
    int m = a.size();
    vector<int> p(n), s, st(n);
    for (int i = 0; i < m; ++i) {
        p[a[i]] = i;
    }
    for (int i = 0; i < m; ++i) {
        if (st[a[i]]) continue;
        while (s.size() && s.back() > a[i] && p[s.back()] > i) {
            st[s.back()] = 0;
            s.pop_back();
        }
        st[a[i]] = 1;
        s.push_back(a[i]);
    }
    return s;
}
```

### å¥½åºåˆ—

æœ‰ä¸€ä¸ªé•¿ä¸ºğ‘›çš„åºåˆ—ğ´1,ğ´2,â€¦,ğ´ğ‘›ã€‚å®šä¹‰ä¸€ä¸ªåºåˆ—{ğ´}æ˜¯å¥½çš„ï¼Œ å½“ä¸”ä»…å½“ä»–çš„æ¯ä¸€ä¸ªå­åŒºé—´[ğ‘™,ğ‘Ÿ]æ»¡è¶³ï¼Œè‡³å°‘å­˜åœ¨ä¸€ä¸ªå…ƒç´ ğ‘¥ä»…å‡ºç°äº†ä¸€æ¬¡ã€‚

+ 1 <= n <= 2e5 
+ 1 <= a[i] <= 1e9

**å¯å‘å¼åˆå¹¶**


```c++
bool isGoodSequence(vector<int> &a) {
    int n = a.size();
    vector<int> pre(n + 1, -1), nxt(n + 1, n + 1);
    map<int, int> mp;
    for (int i = 1; i <= n; ++i) {
        pre[i] = mp[a[i - 1]];
        nxt[mp[a[i - 1]]] = i;
        mp[a[i - 1]] = i;
    }
    function<bool(int, int)> split = [&](int l, int r) -> bool {
        if (l >= r) return 1;
        int x = l, y = r;
        while (x <= y) {
            if (pre[x] < l && r < nxt[x]) return split(l, x - 1) && split(x + 1, r);
            if (pre[y] < l && r < nxt[y]) return split(l, y - 1) && split(y + 1, r);
            x++, y--;
        }
        return 0;
    };
    return split(1, n);
}
```

### åŒºé—´å’Œ

é•¿åº¦ä¸ºnçš„æ•°ç»„A, ç»™å‡ºqä¸ªæç¤ºï¼Œç¬¬iä¸ªæç¤ºæ˜¯Aä¸­Låˆ°Rè¿ç»­å…ƒç´ çš„åŒºé—´å’Œï¼Œèƒ½å¦æ ¹æ®qä¸ªæç¤ºçŸ¥é“æ•°ç»„æ‰€æœ‰å…ƒç´ çš„å’Œï¼Ÿ

**åˆ†æ**

å¯¹äºç»™å®šçš„åŒºé—´å’Œï¼Œæˆ‘ä»¬è€ƒè™‘å‰ç¼€å’Œã€‚

ç»™å®šåŒºé—´ [l,r] çš„å’Œï¼Œç›¸å½“äºå‘Šè¯‰äº†æˆ‘ä»¬ s[r] - s[l - 1]çš„å€¼ï¼Œå¦‚æœæˆ‘ä»¬çŸ¥é“äº†å…¶ä¸­ä¸€ä¸ªæ•°çš„å€¼ï¼Œé‚£ä¹ˆå¦å¤–çš„ä¸€ä¸ªå€¼ä¹Ÿå¯ä»¥å¾—åˆ°ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»™å®šçš„å…³ç³»ï¼Œå¾—åˆ° s[n] çš„å€¼ã€‚æ‰€ä»¥æˆ‘ä»¬ç›´æ¥ç”¨ä¸€ä¸ªå¹¶æŸ¥é›†ç»´æŠ¤å³å¯ã€‚


```c++
struct DSU {
  public:
    DSU() : _n(0) {}
    explicit DSU(int n) : _n(n), parent_or_size(n, -1) {}

    int merge(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        int x = get(a), y = get(b);
        if (x == y) return x;
        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);
        parent_or_size[x] += parent_or_size[y];
        parent_or_size[y] = x;
        return x;
    }

    bool same(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        return get(a) == get(b);
    }

    int get(int a) {
        assert(0 <= a && a < _n);
        if (parent_or_size[a] < 0) return a;
        return parent_or_size[a] = get(parent_or_size[a]);
    }

    int size(int a) {
        assert(0 <= a && a < _n);
        return -parent_or_size[get(a)];
    }

    std::vector<std::vector<int>> groups() {
        std::vector<int> leader_buf(_n), group_size(_n);
        for (int i = 0; i < _n; i++) {
            leader_buf[i] = get(i);
            group_size[leader_buf[i]]++;
        }
        std::vector<std::vector<int>> result(_n);
        for (int i = 0; i < _n; i++) {
            result[i].reserve(group_size[i]);
        }
        for (int i = 0; i < _n; i++) {
            result[leader_buf[i]].push_back(i);
        }
        result.erase(
            std::remove_if(result.begin(), result.end(),
                           [&](const std::vector<int>& v) { return v.empty(); }),
            result.end());
        return result;
    }

  private:
    int _n;
    // root node: -1 * component size
    // otherwise: parent
    std::vector<int> parent_or_size;
};

bool check(int n, vector<array<int, 2>> &Q) {
    DSU dsu(n + 1);
    for (auto& [l, r]: Q) {
        dsu.merge(l - 1, r);
    }
    if (dsu.same(0, n)) return 1;
    return 0;
}
```

## acwing

### å¹³å‡å€¼å¤§äºkçš„æœ€é•¿å­æ•°ç»„é•¿åº¦

[acwing å‘¨èµ›57T3](https://www.acwing.com/problem/content/4490/)


é•¿åº¦ä¸ºnçš„æ•°ç»„A, è¯·ä½ æ‰¾åˆ°ä¸€ä¸ªåºåˆ— a çš„è¿ç»­å­åºåˆ— a[l], a[l+1], ..., a[r]ï¼Œè¦æ±‚:

+ a[l]+a[l+1]+,,,+a[r] > 100 * (r - l + 1)
+ å­æ•°ç»„é•¿åº¦å°½å¯èƒ½å¤§

+ 1 <= n <= 1e6
+ 0 <= a[i] <= 5000

æ±‚å­æ•°ç»„çš„æœ€å¤§å¯èƒ½é•¿åº¦. 


**åˆ†æ**

s[r] - s[l - 1] > 100 (r - l + 1)

å³ï¼š s[r]-s[l-1]-100(r-l+1) > 0

è®¾ s1 ä¸º a[i] - 100 æ•°ç»„çš„å‰ç¼€å’Œï¼Œ
å³ s1[r] > s1[l] (l < r) æ±‚ r - l çš„æœ€å¤§å€¼ã€‚

å¦‚æœ i < j åŒæ—¶ s[i] <= s[j] åˆ™ï¼Œs[j] ä¸ä¼šæˆä¸ºä»»æ„å¤§äºjçš„æœ€å°çš„lï¼Œæ‰€ä»¥å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å‡çš„æ ˆï¼Œæ¯æ¬¡å¯¹æ ˆè¿›è¡ŒäºŒåˆ†ã€‚


**ä»£ç **

```c++
int lengthestSubArray(vector<int> &a, int k) {
    int n = a.size(), ans = 0;
    vector<long long> s(n + 1);
    for (int i = 0; i < n; ++i) 
        s[i + 1] = s[i] + (a[i] - k);
    vector<int> sk;
    for (int i = 0; i <= n; ++i) {
        if (sk.empty() || s[sk.back()] > s[i]) {
            sk.push_back(i);
        } else {
            int l = 0, r = sk.size() - 1, res = -1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (s[sk[mid]] < s[i]) {
                    res = mid;
                    r = mid - 1;
                } else l = mid + 1;
            }
            if (res != - 1)
                ans = max(ans, i - sk[res]);
        }
    }
    return ans;
}
```

**O(n)ç®—æ³•**

å¯¹åŸæ•°ç»„ä½œå‡kæ“ä½œï¼Œè®¾sä¸ºæ–°æ•°ç»„çš„å‰ç¼€å’Œï¼Œé—®é¢˜è½¬åŒ–ä¸ºï¼š
åœ¨sæ•°ç»„ä¸­æ‰¾åˆ°ä¸€å¯¹i,j ä½¿å¾— s[j] > s[i] ä¸” (j - i) æœ€å¤§ã€‚

+ å¯¹äºä¸€ä¸ªiï¼Œå¦‚æœiå·¦ä¾§æœ‰å°äºæˆ–ç­‰äºs[i]çš„å…ƒç´ ï¼Œé‚£ä¹ˆiä¸å¯èƒ½æˆä¸ºæœ€ä¼˜ç­”æ¡ˆä¸­çš„iã€‚
+ å¯¹äºä¸€ä¸ªjï¼Œå¦‚æœjå³ä¾§æœ‰å¤§äºæˆ–ç­‰äºs[j]çš„å…ƒç´ ï¼Œé‚£ä¹ˆjä¸å¯èƒ½æˆä¸ºæœ€ä¼˜ç­”æ¡ˆä¸­çš„jã€‚

è®¾ lmn[i]ï¼šè¡¨ç¤º s[0],...s[i]ä¸­çš„æœ€å°å€¼ï¼Œrmx[j]: è¡¨ç¤ºs[j]...s[n]ä¸­çš„æœ€å¤§å€¼ã€‚

æ˜¾ç„¶ï¼Œlmn å’Œ rmx éƒ½æ˜¯å•è°ƒä¸å¢åºåˆ—ã€‚

ä»å‰å‘åéå†ä¸¤ä¸ªæ•°ç»„ï¼Œå¦‚æœ lmn[i] >= rmx[j]ï¼Œåˆ™æ‰§è¡Œ i++ï¼Œ
å¦‚æœ lmn[i] < rmx[j], æ›´æ–° ans, åŒæ—¶æ‰§è¡Œ j++;


```c++
int lengthestSubArray(vector<int> &a, int k) {
    int n = a.size();
    
    vector<long long> s(n + 1);
    for (int i = 0; i < n; ++i) 
        s[i + 1] = s[i] + (a[i] - k);

    auto lmn = s, rmx = s;
    for (int i = 1; i <= n; ++i) 
        lmn[i] = min(lmn[i - 1], s[i]);
    for (int i = n - 1; i >= 0; --i) 
        rmx[i] = max(rmx[i + 1], s[i]);

    int i = 0, j = 0, ans = 0;
    while (i <= n && j <= n) {
        if (lmn[i] < rmx[j]) {
            ans = max(ans, j - i);
            j = j + 1;
        } else i = i + 1;
    }
    
    return ans;
}
```

### æ‰€æœ‰å­æ•°ç»„å¹³å‡æ•°ä¹‹å’Œ

[ç‰›å®¢å°ç™½æœˆèµ›51 F](https://ac.nowcoder.com/acm/contest/11228/F)

ç»™å®šä¸€ä¸ªæ•°ç»„,æ±‚å‡ºè¿™æ®µæ•°ç»„ä¸­æ‰€æœ‰å­æ•°ç»„çš„å¹³å‡æ•°ä¹‹å’Œã€‚
ç­”æ¡ˆå¯¹1e9+7å–æ¨¡ï¼Œå‡è®¾ç­”æ¡ˆçš„æœ€ç®€åˆ†æ•°è¡¨ç¤ºä¸ºa/b,ä½ éœ€è¦è¾“å‡ºæœ€å°çš„éè´Ÿæ•´æ•°xï¼Œä½¿å¾—`x*b`ä¸aæ¨¡(1e9+7)åŒä½™ã€‚

+ 1 <= n <= 1e6
+ 0 <= a[i] <= 1e9

**åˆ†æ**

```
å¯¹äºä¸åŒé•¿åº¦çš„å­åŒºé—´ï¼Œæ¯ä¸ªå…ƒç´ è´¡çŒ®çš„æ¬¡æ•°

         a[1] a[2] a[3] a[4] a[5] a[6] a[7]
l = 1     1    1    1    1    1    1    1
l = 2     1    2    2    2    2    2    1
l = 3     1    2    3    3    3    2    1
l = 4     1    2    3    4    3    2    1
l = 5     1    2    3    3    3    2    1
l = 6     1    2    2    2    2    2    1
l = 7     1    1    1    1    1    1    1

```

å¯¹äºé•¿åº¦l=1,2,...,nåˆ†åˆ«è€ƒè™‘
å½“l=1æ—¶ï¼Œæ‰€æœ‰é•¿åº¦ä¸º1çš„å­æ•°ç»„å’Œä¸ºs[n]-s[0],è®°ä½œsum[1];
å½“l=2æ—¶ï¼Œa[1]å’Œa[n]è´¡çŒ®ä¸€æ¬¡ï¼Œa[2]...a[n-1]è´¡çŒ®ä¸¤æ¬¡
...
å¯å¾—é€’æ¨å…³ç³»ï¼Œè§ä»£ç ã€‚

æœ€åå¯¹äºæ¯ä¸ªé•¿åº¦è¿›è¡Œç´¯åŠ å’Œï¼Œ a/b = a* pow(b,mod-2)


```c++
int calSubArrayMeanSum(vector<int> &a) {
    int n = a.size(), mod = 1e9 + 7;
    vector<long long> p(n + 1), s(n + 1);
    for (int i = 0; i < n; ++i)
        p[i + 1] = (p[i] + a[i]) % mod;
    for (int l = 1; l <= n; ++l) {
        if (l <= (n + 1) / 2) s[l] = (s[l-1] + p[n + 1 - l] - p[l - 1]) % mod;
        else s[l] = s[n + 1 - l];
    }

    auto qp = [&](long long x, long long y) {
        long long c = 1, t = x;
        for (; y; y >>= 1) {
            if (y & 1) c = c * t % mod;
            t = t * t % mod;
        }
        return c;
    };

    long long ans = 0;
    for (int l = 1; l <= n; ++l) {
        ans = (ans + s[l] * qp(l, mod - 2)) % mod;
    }
    return (ans + mod) % mod;
}
```

### å‡å€¼å¤§äºç­‰äºkçš„å­æ•°ç»„æ•°ç›®

[atcoder arc075E](https://atcoder.jp/contests/arc075/tasks/arc075_c)

ç»™å®šé•¿åº¦ä¸ºnçš„æ•°ç»„kï¼Œæ±‚æœ‰å¤šå°‘å¯¹å­æ•°ç»„ï¼Œå…¶å¹³å‡å€¼å¤§äºç­‰äºkã€‚

+ 1 <= n <= 2e5
+ 1 <= k <= 1e9
+ 1 <= a[i] <= 1e9

**åˆ†æ**

é¦–å…ˆå¯¹æ‰€æœ‰æ•°å‡å»kï¼Œè®¾å…¶å‰ç¼€å’Œæ•°ç»„ä¸ºs,é—®é¢˜è½¬åŒ–ä¸ºæœ‰å¤šå°‘å¯¹l,rä½¿å¾—s[r]-s[l-1]>=0, ç”¨æ ‘çŠ¶æ•°ç»„å¯¹sæ±‚æœ‰å¤šå°‘ä¸ªé¡ºåºå¯¹ã€‚

```c++
long long countSubArraysK(vector<int> &a, int k) {
    int n = a.size();
    vector<long long> s(n + 1), tr(n + 1);
    for (int i = 0; i < n; ++i) {
        s[i + 1] = s[i] + (a[i] - k);
    }

    auto add = [&](int x) {
        for (; x <= n + 1; x += x & -x) tr[x - 1] += 1;
    };

    auto ask = [&](int x) {
        int res = 0;
        for (; x > 0; x -= x & -x) res += tr[x - 1];
        return res;
    };

    auto v = s;
    sort(v.begin(), v.end());
    v.erase(unique(begin(v), end(v)), end(v));

    long long ans = 0;
    for (int i = 0; i <= n; ++i) {
        int p = lower_bound(v.begin(), v.end(), s[i]) - v.begin() + 1;
        ans += ask(p); //å¦‚æœæ˜¯å¤§äºkçš„æ•°ç›®ï¼Œæ”¹ä¸ºask(p-1)
        add(p);
    }
    return ans;
}
```

### æ•°å¯¹

[ç‰›å®¢ æ²³å—èµ›D](https://ac.nowcoder.com/acm/contest/37344/D)

ç»™å®šé•¿åº¦ä¸ºnçš„æ•°åˆ—å’Œä¸¤ä¸ªæ•´æ•°x,y. æ±‚æœ‰å¤šå°‘ä¸ªæ•°å¯¹ l, r, æ»¡è¶³

+ 1 <= l <= r <= n
+ a[l] + a[l+1] + ,,, + a[r]  <= x + y * (r - l + 1)

+ 1 <= n <= 2e5
+ -1e9 <= a[i] <= 1e9
+ -1e12 <= x, y <= 1e12

**è§£æ**

å¦ b[i] = a[i] - y, è®¾bçš„å‰ç¼€å’Œæ•°ç»„ä¸ºsï¼Œä¸Šè¿°å…¬å¼å˜ä¸º s[r] - s[l - 1] <= x
å¯ä»¥åœ¨å€¼åŸŸä¸Šç»´æŠ¤ä¸€ä¸ªæ ‘çŠ¶æ•°ç»„ï¼Œç»´æŠ¤æ¯ä¸ªå‰ç¼€å’Œæ•°å€¼çš„ä¸ªæ•°å’Œã€‚éå†å³è¾¹ç«¯ç‚¹rè¿›è¡Œç´¯åŠ ã€‚

```c++
long long countPairs(vector<int> &a, long long x, long long y) {
    int n = a.size();
    vector<long long> s(n + 1), v;
    for (int i = 0; i < n; ++i) {
        s[i + 1] = s[i] + a[i] - y;
    }

    for (int i = 0; i <= n; ++i) {
        v.push_back(s[i]);
        v.push_back(s[i] - x);
    }

    sort(v.begin(), v.end());
    v.erase(unique(begin(v), end(v)), end(v));

    vector<long long> tr(v.size() + 1);

    auto add = [&](int x) {
        for (; x <= (int)tr.size(); x += x & -x) tr[x - 1] += 1;
    };

    auto ask = [&](int x) {
        int res = 0;
        for (; x > 0; x -= x & -x) res += tr[x - 1];
        return res;
    };

    auto get = [&](long long x) {
        return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
    };

    long long ans = 0;
    for (int i = 0; i <= n; ++i) {
        ans += i - ask(get(s[i] - x) - 1);
        add(get(s[i]));
    }
    return ans;
}
```

**è§£æ³•2**

å¯ä»¥ç›´æ¥ç”¨å¹³è¡¡æ ‘æ±‚ å°äº s[r] - x çš„læœ‰å¤šå°‘ä¸ªã€‚ éœ€è¦ä¸€ä¸ªæ”¯æŒä¸‹è¡¨è®¿é—®çš„multisetã€‚


```c++
struct mulset {
    // mulset æ¨¡æ¿
};

long long countPairs(vector<int> &a, long long x, long long y) {
    int n = a.size();
    vector<long long> s(n + 1), v;
    for (int i = 0; i < n; ++i) {
        s[i + 1] = s[i] + a[i];
    }

    mulset<long long, less<long long>> st;
    st.insert(0);

    long long ans = 0;
    for (int i = 1; i <= n; ++i) {
        ans += i - st.order_of_key(s[i] - x);
        st.insert(s[i]);
    }
    return ans;
}
```
