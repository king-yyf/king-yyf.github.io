---
layout: post
title: 机试选题
date: 2021-10-05
tags: 算法专题  
---


===

Index
---
<!-- TOC -->

- [google oa](#google)
  - [二维矩阵中的好路径数](#二维矩阵中的好路径数)
  - [最少操作次数](#最少操作次数)
  - [字典序最大子序列](#字典序最大子序列)
  - [好路径的数目](#好路径的数目)
  - [最少需要添加元素数](#最少需要添加元素数)
  - [最多删除边数](#最多删除边数)
  - [最多出现次数](#最多出现次数)
  - [树上路径的位运算](#树上路径的位运算)
  - [划分字符串](#划分字符串)
  - [将数组变为0的最小的k](#将数组变为0的最小的k)
  - [下一个美丽的字符串](#下一个美丽的字符串)
  - [最多赢的分数](#最多赢的分数)
- [Amazon oa](#amazon)
  - [找出数组第k大和](#找出数组第k大和)
  - [构造mex数组](#构造mex数组)
  - [最长有效序列](#最长有效序列)
  - [最大递增物品和](#最大递增物品和)
  - [统计子串数目](#统计子串数目)
  - [字典序最小的字符串](#字典序最小的字符串)
  - [子串得分](#子串得分)
  - [好字符串](#好字符串)
  - [数组严格递增的最少操作次数](#数组严格递增的最少操作次数)
  - [n次操作后的最大得分](#n次操作后的最大得分)
  - [包含k个zero子序列的最短字符串长度](#包含k个zero子序列的最短字符串长度)
- [Microsoft oa](#microsoftoa)
  - [统计非重叠区间数](#统计非重叠区间数)
  - [到达office的最少花费](#到达office的最少花费)
  - [打开所有灯泡的最小代价](#打开所有灯泡的最小代价)
  - [前缀和非负的最少移动次数](#前缀和非负的最少移动次数)
  - [能否从b运到e](#能否从b运到e)
  - [相等数组的最长长度](#相等数组的最长长度)
  - [最大收益座位安排](#最大收益座位安排)
  - [所有病人得到预约](#所有病人得到预约)
- [apple/other oa](#appleoa)
  - [树中节点统计](#树中节点统计)
  - [连通分量统计](#连通分量统计)
  - [树的切分方案数](#树的切分方案数)
  - [树上询问](#树上询问)
  - [前缀得分](#前缀得分)
  - [唯一的子序列](#唯一的子序列)
  - [最小区间集合](#最小区间集合)
  - [最小数组长度](#最小数组长度)
  - [移到n的最小代价](#移到n的最小代价)
  - [任意排列数组的最小绝对和](#任意排列数组的最小绝对和)




   
<!-- /TOC -->


## google


### 二维矩阵中的好路径数

有一个`n*m`矩阵, 从(1,1)开始，走到(n,m)，每一步只能向右走或向下走，如果经过路径上的数字之和能被k整除，则称为一条好的路径，求好路径的数目。

+ 1 <= n, m <= 16
+ 1 <= a[i], k <= 1e18

**分析**

双向dfs 类似题目[cf 1006f](https://codeforces.com/problemset/problem/1006/F)

```c++
long long count_good_paths(vector<vector<long long>> &a, long long k) {
    int n = a.size(), m = a[0].size();
    long long res = 0;

    map<long long, long long> mp[n];

    function<void(int, int, long long)> dfs_pre = [&](int x, int y, long long s) {
        if (x + y == (n + m - 2) / 2) {
            mp[x][s]++;
            return;
        }
        if (x + 1 < n) dfs_pre(x + 1, y, (s + a[x + 1][y]) % k);
        if (y + 1 < m) dfs_pre(x, y + 1, (s + a[x][y + 1]) % k);
    };

    function<void(int, int, long long)> dfs_suf = [&](int x, int y, long long s) {
        if (x + y == (n + m - 2) / 2) {
            if (mp[x].count((((a[x][y] % k) - s + k) % k))) 
                res += mp[x][(((a[x][y] % k) - s + k) % k)];
            return;
        }
        if (x > 0) dfs_suf(x - 1, y, (s + a[x - 1][y]) % k);
        if (y > 0) dfs_suf(x, y - 1, (s + a[x][y - 1]) % k);
    };

    dfs_pre(0, 0, a[0][0] % k);
    dfs_suf(n - 1, m - 1, a[n - 1][m - 1] % k);

    return res;
}
```

### 最少操作次数

[google oa](https://leetcode.com/discuss/interview-question/2616448/Google-OA)

长度为n的整数数组a,每次操作可以选择任意元素将其加一。求最少的操作次数，使得：
任意长度大于等于3的子数组，其最大值都大于等于k.

+ 1 <= n <= 1e5
+ 0 <= a[i], k <= 1e9

示例:
input: a = [2, 1, 1, 3], k = 5
output: 4
解释：4次操作可以将a变成[2,1,5,3]


```c++
void minOperations(vector<int> &a, int k) {

}
```

### 字典序最大子序列

[google oa](https://leetcode.com/discuss/interview-question/2616381/Google-OA-2022)

给定长度为n的字符串s,对于i=1,...,n，求长度为i的字典序最大的子序列。例如 `s="hrw"`
`ans = ["w", "rw", "hrw"]`

+ 1 <= n <= 1000

```c++
vector<string> maxLexsubSeq(string &s) {
    int n = s.size();
    vector<string> ans(n);
    vector<pair<char,int>> a;
    for (int i = 0; i < n; ++i) {
        a.push_back({s[i], i});
    }
    sort(a.rbegin(), a.rend());

    string t;
    for (int i = 0; i < n; ++i) {
        int j = i;
        while (j > 0 && a[j].second < a[j - 1].second) {
            swap(a[j], a[j - 1]);
            j--;
        }
        t.insert(t.begin() + j, a[j].first);
        ans[i] = t;
    }
    return ans;
}
```

### 好路径的数目

给定一棵n个节点的树，每个节点有一个值，一条好路径满足：
路径上任意节点的值出现的频率都至少是路径长度的一半(下取整)。节点u,v的路径长度定义为u,v简单路径上的节点数目。
求从节点1出发的好路径的数目。

[google oa13](https://www.desiqna.in/5629/google-oa-coding-questions-and-solutions-set-13-2022)

+ 1 <= n <= 1e5
+ 1 <= a[i] <= 1e5

```c++
int goodPaths(vector<vector<int>> &es, vector<int> &a) {
    int n = a.size();
    vector<vector<int>> g(n);
    for (auto &e: es) {
        g[e[0]].push_back(e[1]);
        g[e[1]].push_back(e[0]);
    }
    int ans = 0;
    map<int, int> mp;
    function<void(int, int)> dfs = [&](int u, int fa) {
        mp[a[u]]++;

        if (mp.size() == 1) ans++;
        else if (mp.size() == 2) {
            int u = mp.begin()->second, v = mp.rbegin()->second;
            if (abs(u - v) <= 1) ans++;
        }
        for (int v: g[u]) {
            if (v == fa) continue;
            dfs(v, u);
        }
        mp[a[u]]--;
        if (mp[a[u]] == 0) mp.erase(a[u]);
    };
    dfs(0, -1);
    return ans;
}
```


### 最少需要添加元素数

[google oa 27](https://www.desiqna.in/7154/google-oa-subsequence-set-27-usa)

数组a，长度n，各元素互不相同，数组b，长度为m，元素可能有相同，求，至少在b中任意位置添加多少个数，使a变为b的子序列。

+ 1 <= n,m <= 1e5
+ 1 <= a[i], b[i] <= 1e9

输入格式：
第一行样例数t,每个样例第一行n,m, 后面两行分别为a,b

input：
```
1
5 6
1 2 3 4 5
2 5 6 4 9 12
```

output:
```
3
```

input:
```
2
9 19
1 2 4 6 15 18 19 24 29
12 19 19 5 26 2 23 9 23 14 29 7 28 24 28 29 21 16 16
16 10
1 2 3 4 8 9 11 12 14 17 19 21 24 26 28 29
11 18 8 9 9 15 24 26 16 18
```

output:
```
6
12
```

**分析**

求出a,b最长公共子序列k，答案为n-k，由于a中元素互不相同，最长公共子序列可以转化为最长上升子序列.

```c++
int lengthOfLIS(vector<int>& nums) {
    vector<int> res;
    for (int i = 0; i < nums.size(); ++i) {
        auto it = lower_bound(res.begin(), res.end(), nums[i]);
        if (it == res.end()) res.push_back(nums[i]);
        else *it = nums[i];
    }
    return res.size();
}
int minAddElement(vector<int> &a, vector<int> &b) {
    int n = a.size();
    set<int> s(a.begin(), a.end());
    vector<int> c;
    for(auto &x: b) if (s.count(x)) 
        c.push_back(x);
    int k = lengthOfLIS(c);
    return n - k;
}
```

### 最多删除边数

[google oa 25](https://www.desiqna.in/6965/google-oa-remove-maximum-edges-set-25)

一颗n个节点的树，每个节点都有一个值，用数组a给出，最多能从树中删除多少边，使得剩余的所有连通子树的节点和相等。输出最多边数。

+ 1 <= n <= 1e5
+ 1 <= a[i] <= 1e3

<br />
![](/images/posts/leetcode/google_1.png)
<br />

**分析**

树中节点总和不超过1e8, 小于1e8的数中，最多有不超过100个因子。
对所有的因子，从小到大检查最多能分出的连通分量数，如果满足条件，则返回解。

```c++
int maxDelectEdge(vector<int> &a, vector<vector<int>>& es) {
    int n = a.size(), target, cnt, sum = accumulate(a.begin(), a.end(), 0);
    vector<vector<int>> g(n);
    vector<int> s(n), f, p;

    for (auto & e : es) {
        g[e[0]].push_back(e[1]);
        g[e[1]].push_back(e[0]);
    }

    function<void(int, int)> dfs = [&](int u, int fa) {
        s[u] += a[u];
        for(int v : g[u]){
            if(v != fa){
                dfs(v, u);
                s[u] += s[v];
            }
        }
    };

    dfs(0, -1);  // 计算子树和

    for (int k = 1; k * k <= sum; ++k) {
        if (sum % k == 0) {
            f.push_back(k);
            if (k != sum / k) f.push_back(sum / k);
        }
    }
    sort(f.begin(), f.end());

    function<void(int, int)> dfs1 = [&](int u, int fa) {
        if (s[u] == target) {
            cnt++, p[u] = 1;
            return;
        }
        for (int v : g[u]) {
            if (v != fa) {
                dfs1(v, u);
                p[u] += p[v];
            }
        }
        if (s[u] - p[u] * target == target) cnt++, p[u]++;
    };

    for(int fac : f) {
        target = fac, cnt = 0;
        p.assign(n, 0);
        dfs1(0, -1);
        if (cnt * fac == sum) return cnt - 1;
    }
    return 0;
}
```

### 最多出现次数

[google oa21](https://www.desiqna.in/6785/google-oa-coding-questions-and-solutions-set-21-2022-usa)

长度为n的数组a，每次可以选择任意下标，将该下标处得到元素加k,但是其余元素会减k，可以进行任意次操作，你的目标是使数组中不同的元素个数最少，求最后数组中出现次数最多的元素出现了多少次

+ 1 <= n <= 1000
+ 0 <= k, a[i] <= 1000

**分析**

每次操作相当于选择一个元素，将其加2k, 当两个元素模 2k的余数相同时，两个元素能变成相同元素。

示例1
input
```
3 1
3 1 3
```

output:
`3`

示例2
input
```
3 1
1 2 2
```

output:
`2`

```c++
int maxtimes(vector<int> &a, int k) {
    int m = 2 * k, n = a.size();
    map<int, int> mp;
    for (int i = 0; i < n; ++i) {
        int x = m > 0 ? a[i] % m : a[i];
        mp[x]++;
    }
    int ans = 0;
    for (auto &[_, v]: mp) {
        ans = max(ans, v);
    }
    return ans;
}
```

### 树上路径的位运算

[google oa15](https://www.desiqna.in/5883/google-oa-coding-questions-and-solutions-set-2022-sde-india)

n个节点的树，每条边有个权重，用数组w给出，q个询问，每个询问给定x,y，对于每个询问，计算x,y简单路径上权重的 xor, and, or值。

+ 1 <= n <= 1e5
+ 0 <= w[i] <= 1e9

<br />
![](/images/posts/leetcode/google_2.png)
<br />


```c++
vector<vector<int>> bitwise_tree(vector<vector<int>> &es, vector<vector<int>> &q) {
    int n = es.size() + 1;
    vector<vector<pair<int,int>>> g(n);
    LCA lca(n);
    for (auto& e: es) {
        g[e[0]].push_back({e[1], e[2]});
        g[e[1]].push_back({e[0], e[2]});
        lca.add_edge(e[0], e[1]);
    }
    lca.build();
    vector s(n, vector<int>(32));
    vector<int> e(n);

    function<void(int, int)> dfs = [&](int u, int fa) {
        for (auto &[v, p] : g[u]) {
            if (v != fa) {
                for (int i = 0; i < 32; ++i)
                    s[v][i] = s[u][i] + ((p & (1 << i)) ? 1 : 0);
                e[v] = e[u] + 1;
                dfs(v, u);
            }
        }
    };

    dfs(0, -1);

    vector<vector<int>> ans(q.size());

    for (int i = 0; i < q.size(); ++i) {
        int x = q[i][0], y = q[i][1], u = lca.get_lca(x, y);
        int _xor = 0, _and = 0, _or = 0, cnt = e[x] + e[y] - 2 * e[u];
        for (int i = 0; i < 32; ++i) {
            int c = s[x][i] + s[y][i] - 2 * s[u][i];
            if (c % 2 == 1) _xor |= (1 << i);
            if (c >= 1) _or |= (1 << i);
            if (c == cnt) _and |= (1 << i);
        }
        ans[i] = {_xor, _and, _or};
    }
    return ans;
}
```

### 划分字符串

[google oa](https://docs.google.com/document/d/1PIiMYOIWu2jF2eIMyg6xw_KX4W9u6fU3NKElSYFkvUo/edit#)

长度为n的字符串s，每个字符0-9,求满足下述要求的划分方案数， mod 1e9+7,
1. 每个子字符串长度至少为m
2. 每个子字符串从奇数数字开始，偶数数字结束.
3. 恰好划分k个连续的子字符串

+ 1 <= n <= 2000
+ k, m <= n

**分析**

如果第一个字符不是奇数，或者最后一个字符不是偶数，答案就是0。
f[i][j] 表示以第i个字符为最后一个分段的结尾，且一共分了j段的方案数.首先检查第i个字符能否能成为一段的结尾，它需要满足以下条件

+ s[i] 为偶数
+ s[i + 1] 为奇数，或s[i]为整个字符串最后一个字符

如果第i个字符能成为一段的结尾，有突下递推式

`f[i][j] = f[0][j-1]+...+f[i-m][j-1]`

这个递推式就是在枚举上一段的结尾是哪个字符。直接套用递推式的复杂度是 O(n*n*k). 另外维护一个前缀和 
`g[i][j] = f[0][j] + ... + f[i][j]`

初始值 f[0][0] = g[0][0] = 1, 复杂度 `O(n*k)`

```c++
int partitionString(string &s, int k, int m) {
    int n = s.size(), mod = 1e9 + 7;
    auto chk = [&](char c) {
        return (c - '0') & 1;
    };

    if (!chk(s[0]) || chk(s[n - 1])) return 0;

    vector<vector<int>> f(n + 1, vector<int>(k + 1)), g(n + 1,vector<int>(k + 1));

    f[0][0] = g[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        if (i >= m && !chk(s[i - 1]) && (i == n || chk(s[i]))) {
            for (int j = 1; j <= k; ++j) 
                f[i][j] = g[i - m][j - 1];
        }
        for (int j = 0; j <= k; ++j) 
            g[i][j]  = (g[i - 1][j] + f[i][j]) % mod;
    }
    return f[n][k];
}
```

### 将数组变为0的最小的k

[google oa](https://leetcode.com/discuss/interview-question/2676336/Google-OA-or-GOCC56)

给定长度为n的数组a和整数m，使用如下条件将数组元素全部变为0: 选择一个整数k，执行下面操作至多m次

+ 选择一个下标i (0 <= i < n)
+ 赋值 a[i] = max(0, a[i] - k)

求满足上述条件的最小的k。

+ 1 <= n <= 1e5
+ n <= m <= 1e12
+ 1 <= a[i] <= 1e12


```c++
long long minKzeroArray(vector<long long> &a, int m) {
    long long l = 0, r = 1e12, mn = r;
    while (l <= r) {
        long long md = (l + r) / 2;
        long long c = 0;
        for (auto &x: a) 
            c += max(0ll, (x + md - 1) / md);
        if (c <= m) {
            mn = md;
            r = md - 1;
        } else l = md + 1;
    }
    return mn;
}
```

### 下一个美丽的字符串

[google oa](https://leetcode.com/discuss/interview-question/2676336/Google-OA-or-GOCC56)


一个字符串s是美丽的，如果s的每一个字母都是小写英文字母的前k个字母，且不含长度大于等于2的回文子串,给定一个长度为n的美丽字符串s，求字典序最小的长度为n的美丽字符串t，满足t的字典序大于s。如果没有，返回空串。

+ 1 <= n <= 1e5
+ 1 <= k <= 26

**分析**

不含长度大于等于2的回文子串,即s[i]!=s[i-1]且s[i]!=s[i-2]

```c++
string minBeautString(string &s, int k) {
    int n = s.size(), mc = 'a' + k;
    int i = n - 1;
    s[i]++;
    while (i >= 0 && i <= n - 1) {
        if (s[i] >= mc) {
            s[i] = 'a';
            s[--i]++;
        } else if ((i > 0 && s[i] == s[i - 1]) || (i > 1 && s[i] == s[i - 2])) {
            s[i]++;
        }  else i++;
    }
    return s;
 }
 ```

### 最多赢的分数

[google oa28](https://www.desiqna.in/7959/google-oa-ronnie-and-donnie-set-28-iit-2022)

有偶数个数值，两位玩家A和B，从数组两端取数，A先手，B后手，B始终采取贪心策略，每次取两端中更大的一个,求A采取最有策略的条件下，最红与B得分的最大差值（得分为每个人所选数的和）

+ 1 <= n <= 1000
+ n是偶数
+ sum(a[1,..n]) <= 1e6

```c++
int maxScodeDiff(vector<int> &a) {
    int n = a.size();

    function<pair<int,int>(int, int)> dfs1;
    function<pair<int,int>(int, int)> dfs2;

    map<pair<int,int>,pair<int,int>> dp1,dp2;

    dfs1 = [&](int i, int j) {
        if (dp1.count({i, j})) return dp1[{i, j}];
        if (i == j) {
            dp1[{i, j}] = {a[i], 0};
            return dp1[{i, j}];
        }
        pair<int, int> d1{a[i] + dfs2(i + 1, j).first, dfs2(i + 1, j).second};
        pair<int, int> d2{a[j] + dfs2(i, j - 1).first, dfs2(i, j - 1).second};

        if (d1.first - d1.second >= d2.first - d2.second) {
            dp1[{i, j}] = d1;
            return d1;
        }
        dp1[{i, j}] = d2;
        return d2;
    };

    dfs2 = [&](int i, int j) {
        if (dp2.count({i, j})) return dp2[{i, j}];
        if (i == j) {
            dp2[{i, j}] = {0, a[i]};
            return dp2[{i, j}];
        }
        pair<int, int> d1{dfs1(i + 1, j).first, dfs1(i + 1, j).second + a[i]};
        pair<int, int> d2{dfs1(i, j - 1).first, dfs1(i, j - 1).second + a[j]};
        if (a[i] > a[j] || (a[i] == a[j] && d1.first - d1.second >= d2.first - d2.second)) {
            dp2[{i, j}] = d1;
            return d1;
        } 
        dp2[{i, j}] = d2;
        return d2;
    };

    auto [x, y] = dfs1(0, n - 1);

    return x - y;
}
```


## amazon

### 找出数组第k大和

[lc 周赛307 T4](https://leetcode.cn/problems/find-the-k-sum-of-an-array/)

给你一个整数数组 nums 和一个正整数 k 。你可以选择数组的任一 **子序列** 并且对其全部元素求和。

数组的 第 k 大和 定义为：可以获得的第k个最大子序列和（子序列和允许出现重复）

返回数组的 第 k 大和 。

**注意：空子序列的和视作 0**

+ 1 <= nums.size() <= 1e5
+ -1e9 <= nums[i] <= 1e9
+ 1 <= k <= min(2000, 2^n)

**分析**

**简化问题**

考虑本题的简化问题：给定 n 个非负数 a[1],...,a[n]，求第 k 个最 小 的子序列和。

这是一个经典问题。我们先把所有数从小到大排序，记(s,i) 表示一个总和为 s, 且最后一个元素是第 i个元素的子序列。

我们用一个小根堆维护(s,i), 一开始堆中只有一个元素(a[1],1), 当我们取出堆顶元素(s,i)时，可以进行以下操作

+ 把a[i+1]接到这个子序列的后面形成新的子序列，也就是将(s+a[i+1],i+1)放入堆中
+ 把子序列中的a[i],直接替换为a[i+1],也就是将(s+a[i+1]-a[i],i+1)放入堆中

第 (k−1) 次取出的 (s,i) 中的 s 就是答案（k=1 时答案为空集之和，也就是 0）。

这个做法的正确性基于以下事实：

+ 这种方法能不重不漏地生成所有子序列。
+ 每次放进去的数不小于拿出来的数

**最小和变最大和**

实际上，求第 k 个最大的子序列和，与求第 k 的最小的子序列和是一样的。我们求出 k 小子序列后取反（选择不在答案中的所有元素作为新的答案），就能得到 k 大子序列。因此所有元素之和减去 k 小子序列和，就能得到 k 大子序列和。

**引入负数**

回到原问题，考虑给定的数中有负数的情况， 首先计算 m 表示所有负数的和，然后把所有负数变成它们的绝对值（这样就回到了全是非负数的情况）。答案就是 m 加上 k 大子序列和。

为什么这样是对的？考虑由此得到的 k 大子序列，它实际上唯一对应了一个原有的子序列。我们举个例子：

+ 一开始a = [-3, -2, -1, 4, 5, 6]
+ 经过转换之后，我们得到k大子序列{2,1,5,6}
+ 对于所有在该子序列中的非负数，令它成为答案的一部分，也就是说 5 和 6 是答案的一部分；
+ 对于所有不在该子序列中的负数，令它成为答案的一部分，也就是说 −3 是答案的一部分；
+ 最后得到真实答案 [-3,5,6]

```c++
typedef pair<long long, int> pli;
long long kMaxsum(vector<int> &a, int k) {
    int n = a.size();
    long long s = 0, sn = 0;
    for (int &x : a)  {
        s += x;
        if (x < 0) sn += x, x = -x;
    }
    sort(a.begin(), a.end());
    long long ans = 0;
    priority_queue<pli, vector<pli>, greater<pli>> pq;
    pq.push({a[0], 0});
    for (int i = 2; i <= k; ++i) {
        auto [x, y] = pq.top(); pq.pop();
        ans = x;
        if (y == n -  1) continue;
        pq.push({x + a[y + 1], y + 1});
        pq.push({x + a[y + 1] - a[y], y + 1});
    }
    return s - (sn + ans);
}
```

### 构造mex数组

[geeks](https://www.geeksforgeeks.org/construct-mex-array-from-the-given-array/)

给定长度为n的数组a[i]，**包含n个不同的数**,构造另一个长度为n的数组c，其中c[i]表示删除a[i]后，a中缺失的最小正数。

+ 1 <= n <= 1e5
+ 1 <= a[i] <= 1e5

```c++
vector<int> mex_array(vector<int> &a) {
    int n = a.size(), mx = *max_element(a.begin(), a.end());
    vector<int> f(mx + 1);
    for(auto&x: a) 
        f[x] = 1;
    int mex = 1;
    while (mex <= mx && f[mex] == 1) mex++;

    vector<int> c(n);
    for (auto&x: a) {
        if (x < mex) c[i] = x;
        else c[i] = mex;
    }
    return c;
}
```

### 最长有效序列

给定两个长度为n的正整数数组a,b, 和一个整数t，求满足下述公式的最长子数组：
`max(b[i,..,j]) + sum(a[i,..,j] * (j - i + 1)) <= t` ,如果无解，返回0.


+ 1 <= n <= 1e5
+ 1 <= a[i] <= 1e9
+ 1 <= t <= 1e14

**分析**

双指针 + 单调队列维护滑动窗口最大值

```c++
int maxValidSubArray(vector<int> &a, vector<int> &b, long long t) {
    int n = a.size(), ans = 0;
    deque<int> q;
    long long s = 0;
    for (int i = 0, j = 0; j < n; ++j) {
        s += a[j];
        while (!q.empty() && b[q.back()] <= b[j]) q.pop_back();
        q.push_back(j);
       
        while (i <= j && b[q.front()] + s * (j - i + 1) > t) {
            if (q.front() == i) q.pop_front();
            s -= a[i];
            i++;
        }
        ans = max(ans, j - i + 1);
    }
    return ans;
}
```

### 最大递增物品和

给定一个长度为n的数组，a[i]表示第i堆有a[i]个物品，你可以选择一个连续区间进行取货，取出的物品数量必须是递增的，求能取出的最大物品。
示例：a=[7,4,5,2,6,5]
你可以选择[7,4,5]这个区间，能取到的最多物品为[3,4,5]，其和为12，因为取出的物品必须是递增的，你也可以选择[5,2,6,5]这个区间，分别能取出[1,2,4,5]，总和也是12.

+ 1 <= n <= 1e5


**分析**

dp[i] 表示以 i 位置元素结尾的最大物品数，则 dp[i] = 等差数列求和[j..i] + dp[j]。
利用单调栈寻找 j 的位置，即 last smaller element，条件为横坐标的差值。

```c++
long long maxIncresceSum(vector<int> &a) {
    int n = a.size(), k;
    long long s = 0;
    vector<long long> dp(n);
    stack<int> sk;
    for (int i = 0; i < n; ++i) {
        while (!sk.empty() && a[sk.top()] >= a[i] - (i - sk.top())) sk.pop();
        k = sk.empty() ? min(i + 1, a[i]) : i - sk.top();
        dp[i] = (a[i] + a[i] - len + 1) * len / 2 + (sk.empty() ? 0 : dp[sk.top()]);
        s = max(s, dp[i]);
        sk.push(i);
    }
    return s;
}
```

### 统计子串数目

给定长度为n的二进制字符串，统计有多少个子串满足下述条件：
+ '0' 和 '1' 都是连续出现的
+ '0' 的数目 等于 '1' 的数目
+ 1 <= n <= 5e5

```c++
long long countSumString(string &s) {
    long long ans = 0, x =  0, y = 1;
    for (int i = 1; i < (int)s.size(); ++i) {
        if (s[i] != s[i - 1]) {
            ans += min(x, y);
            x = y;
            y = 1;
        }else y++;
    }
    ans += min(x, y);
    return ans;
}
```

### 字典序最小的字符串

[lc周赛314 T3](https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/)

给你一个字符串 s 和一个机器人，机器人当前有一个空字符串 t 。执行以下操作之一，直到 s 和 t 都变成空字符串：
+ 删除字符串 s 的 第一个 字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。
+ 删除字符串 t 的 最后一个 字符，并将该字符给机器人。机器人将该字符写到纸上。
请你返回纸上能写出的字典序最小的字符串。

+ 1 <= s.size() <= 1e5
+ s只包含小写字母

**分析**

本题是经典贪心：求出栈序列的最小字典序。
我们首先将题目描述进行转化：有一个初始为空的栈，给定字符的入栈顺序，求字典序最小的出栈序列。

当一个字符入栈后，我们持续检查栈顶元素 c。设还未入栈的字符中，字典序最小的字符是 m，有以下两种情况。

+ c≤m：此时弹出 c 最优。如果此时按兵不动，下一个出栈的将会是大等于 c 的字符，答案不会变优。
+ c>m：此时不弹出 c，等待后续更小的字符入栈。

所有字符都入栈后，栈内的剩余字符按顺序弹出即可。复杂度 \mathcal{O}(n)O(n)。

```c++
string robotWithString(string s) {
    int n = s.size();
    vector<char> f(n + 1);
    f[n] = 'z' + 1;
    for (int i = n - 1; i >= 0; i--) f[i] = min(f[i + 1], s[i]);

    string ans;
    stack<char> stk;
    for (int i = 0; i < n; i++) {
        stk.push(s[i]);
        while (!stk.empty() && stk.top() <= f[i + 1]) ans.push_back(stk.top()), stk.pop();
    }
    return ans;
}
```

### 子串得分

[amazon oa 101](https://www.desiqna.in/8174/amazon-sde1-coding-questions-and-solutions-2022-set-101-india)

字符串s，长度为n，只包含小写字母，字符串得分定义为字符串中各字符出现次数的异或和。有两种不同query.
+ 1 L R: 求s[L..R]的score
+ 2 X Y: 将s[x] 赋值为第i个字符

+ 1 <= n <= 1e5
+ 1 <= q <= 1e5
+ 1 <= x,l,r <= n
+ 1 <= y <= 26

```c++
vector<int> stringScore(string &s, vector<vector<int>> &qs){
    int n = s.size();

    vector tr(n, vector<int>(26));

    auto add = [&](int x, int y, int c) {
        for (; x <= (int)tr.size(); x += x & -x) tr[x - 1][y] += c;
    };
    
    auto ask = [&](int x, int y) {
        int res = 0;
        for (; x > 0; x -= x & -x) res += tr[x - 1][y];
        return res;
    };

    for (int i = 0; i < n; ++i) {
        add(i + 1, s[i] - 'a', 1);
    }
    
    vector<int> ans;
    for(auto& q: qs) {
        int op = q[0], x = q[1], y = q[2];
        if (op == 1) {
            int res = 0;
            for (int i = 0; i < 26; ++i) {
                int cnt = ask(y + 1, i) - ask(x, i);
                res ^= cnt;
            }
            ans.push_back(res);
        } else {
            int c = s[x] - 'a';
            add(x + 1, c, -1);
            add(x + 1, y, 1);
            s[x] = char('a' + y);
        }
    }
    return ans;
}
```

### 好字符串

[amazon oa 101](https://www.desiqna.in/8174/amazon-sde1-coding-questions-and-solutions-2022-set-101-india)

给定字符串s(只包含小写字母)，长度为n，q个区间[l,r],和一个1-N的排列。

每一次操作，你会按照排列中的元素下标顺序删掉字符串中的元素，但剩余元素位置不变。
例如 s = "acbca", 排列 = [3,4,1,5,2]
第1次操作，s变为 ac_ca
第2次操作，s变为 ac__a
第3次操作，s变为 _c__a
第4次操作，s变为 _c___
第5次操作，s变为 _____

求至少操作多少次，使得每个区间构成的子串中的元素都是不同的(没有重复元素)

+ 1 <= n <= 1e5
+ 1 <= q <= 1e5
+ 1 <= a[i] <= n
+ 1 <= l <= r <= n

input1：
```
1
8 3
abbabaab
6 3 5 1 4 2 7 8
1 3
4 7
3 5
```
output1:
`5`

input2:
```
1
5 2
aaaaa
2 4 1 3 5
1 2
4 5
```

output2:
`2`

```c++
int minOperations(string &s, vector<vector<int>> &qs, vector<int> a) {
    int n = s.size();
    int l = 0, r = n, mn = n;

    auto chk = [&](int x) {
        string t = s;
        for (int i = 0; i < x; ++i) {
            t[a[i]] = '_';
        }
        vector<vector<int>> p(n+1,vector<int>(26));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 26; ++j) {
                p[i + 1][j] = p[i][j] + (t[i] == 'a' + j);
            }
        } 
        for (auto &q : qs) {
            for (int i = 0; i < 26; ++i) 
                if (p[q[1] + 1][i] - p[q[0]][i] > 1) return 0;
        }
        return 1;
    };

    while (l <= r) {
        int md = (l + r) / 2;
        if (chk(md)) {
            mn = md;
            r = md - 1;
        }else l = md + 1;
    }
    return mn;
}
```

### 数组严格递增的最少操作次数

[amazon oa](https://cybergeeksquad.co/2022/11/trees-height-solution-amazon-oa-sde.html)

一个长度为n的数组，每次操作可以选择数组中任意一个数+1,或者-1, 求让数组变为严格递增数组所需的最少操作次数。
可以让数组中元素变为0或负数。

+ 1 <= n <= 3000
+ 1 <= a[i] <= 1e9

**分析**

**问题1** ：给定数组，最少操作次数(+1,-1)使数组中元素全部相等。

对于每一个前缀数组，其最优方案为让所有元素变为该数组的中位数，可以使用两个堆维护数据流中的中位数。

**问题2**: 给定数组，最少操作次数(+1,-1) 使数组中元素变为不下降序列。

[cf 13c](https://codeforces.com/problemset/problem/13/C)

**首先所有数最后所变成的数一定是原序列中有的数**，设a为原数组，b为a排序后的数组，且b中无重复元素。

f[i][j] 表示让数组中前i个元素非递减，且第i个元素最大为b[j]的情况下的最少操作次数，最终答案为f[n][k], k为b数组的长度。

```c++
f[1][1] = abs(a[1] - b[1])
f[1][j] = min(f[1][j - 1], abs(a[1] - b[j]))
f[i][1] = abs(a[i] - b[1]) + f[i - 1][1]
f[i][j] = min(f[i][j - 1], f[i - 1][j] + abs(a[i] - b[j]))
```

**本问题**：

dp[i]:使前i个元素递增的最少操作次数, 首先操作a[i]=a[i]-i,则该问题转化为问题2.


```c++
long long minOperations(vector<int> &a) {
    int n = a.size();
    vector<long long> b(n), f(n);
    for (int i = 0; i < n; ++i) {
        a[i] -= i;
        b[i] = a[i];
    }
    sort(b.begin(), b.end());
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            f[j] += abs(a[i] - b[j]);
            if (j > 0 && f[j - 1] < f[j]) f[j] = f[j - 1];
        }
    }
    return f[n - 1];
}
```

**方法2**

+ 时间复杂度 `O(n*log(n))`

```c++
long long minOperations(vector<int> &a) {
    int n = a.size();
    long long ans = 0;
    priority_queue<int> q;
    for (int i = 0; i < n; ++i) {
        a[i] -= i;
        q.push(a[i]);
        if (q.top() > a[i]) {
            ans += q.top() - a[i];
            q.pop();
            q.push(a[i]);
        }
    } 
    return ans;
}
```

### n次操作后的最大得分

长度为2n的数组，需要执行n次操作，第i次操作中(i=1,..n)：

+ 选择两个数组中的元素x,y,本次操作得分为 i * gcd(x,y),
+ 从数组中删除x,y

求n次操作后的最大得分。

+ 1 <= n <= 7
+ 1 <= a[i] <= 1e6

**分析**

状态压缩dp。

```c++
int maxSocre(vector<int> &a) {
    int n = a.size();
    vector g(n, vector<int>(n));
    for (int i = 0; i < n; ++i)
        for (int j = i + 1; j < n; ++j)
            g[i][j] = gcd(a[i], a[j]);

    vector dp(n + 1,vector<int> (1 << n));

    function<int(int, int)> dfs =[&](int idx, int st) {
        if (idx - 1 == n / 2) return 0;
        if (dp[idx][st]) return dp[idx][st];
        int res = 0;
        for (int i = 0; i < n; ++i) {
            if ((st >> i) & 1) continue;
            for (int j = i + 1; j < n; ++j) {
                if ((st >> j) & 1) continue;
                res = max(res, idx * g[i][j] + dfs(idx + 1, st | (1 << i) | (1 << j)));
            }
        }
        return dp[idx][st] = res;

    };
    
    return dfs(1, 0);
}
```

### 包含k个zero子序列的最短字符串长度

[amazon oa](https://leetcode.com/discuss/interview-question/2325441/Amazon-Online-Assessment-Question)


输入k，求包含大于等于k个"zero"子序列的最短字符串长度。例如， k = 2时，"zzero", "zeero","zerro","zeroo" 都包含2个zero子序列，且长度最短，因此答案是5.

+ 1 <= k <= 1e9

类似题目：[cf1368b](https://codeforces.com/contest/1368/problem/B)

```c++
// s = "zero" 或者其他字符串
int minimumLengStr(string &s, int k) {
    int n = s.size();
    vector<long long> a(n, 1);
    long long sum = 1;
    for (int i = 0; sum < k; i = (i + 1) % n) {
        sum = sum / a[i] * (a[i] + 1);
        ++a[i];
    }

    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ans += a[i];        
    }

    return ans;
}
```

如果需要输出其中满足条件的一个最短字符串，则

```c++
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < a[i]; ++j)
        cout << a[i];
}
```


## microsoftoa

### 统计非重叠区间数

[microsoft oa26](https://www.desiqna.in/8435/microsoft-oa-coding-questions-and-solutions-set-26-2022)

n个区间，每个区间表示为[l,r],从中选择3个互不重叠的区间，共有多少种方案。注意 [2,3]，[3,5]算有重叠元素3.

+ 1 <= n <= 1e5
+ 1 <= l <= r <= 1e9

**分析**

统计每个区间，开始位置左边有多少个不重叠区间，结束位置右边有多少个满足条件的区间即可。

```c++
long long countRanges(vector<vector<int>> &rs) {
    long long ans = 0, cnt_l = 0, n = rs.size();
    priority_queue<int, vector<int>, greater<int>> q;
    sort(rs.begin(), rs.end(),[&](auto &x, auto &y){
        return x[0] < y[0];
    });

    for (int i = 0; i < n; ++i) {
        while (q.size() && q.top() < rs[i][0]) {
            cnt_l++; q.pop();
        }
        int l = i + 1, r = n - 1, cnt_r = 0;
        while (l <= r) {
            int md = (l + r) / 2;
            if (rs[md][0] > rs[i][1]) {
                cnt_r = n - md;
                r = md - 1;
            }else l = md + 1;
        }
        ans += cnt_l * cnt_r;
        q.push(rs[i][1]);
    }
    return ans;
}
```

### 到达office的最少花费

[microsoft oa18](https://www.desiqna.in/7188/microsoft-sde-role-campus-coding-questions-solutions-2022)

一个n条边，n+1个节点的树，0号节点是办公室，1-N号节点各住一名工人，所有工人乘车去上班，一辆车最多可以承载5人，从一个节点到相邻节点消耗1升汽油，求最佳拼车模式下，所有工人到达办公室消耗的最少汽油。

+ 1 <= n <= 1e5
+ 0 <= es[i] <= n
+ 所有边组成一棵树

input1:
```
[[0,1],[1,2],[1,3]]
```

output1:
`3`

input2:
```
[[1,2],[1,0],[1,3],[9,1],[9,6],[9,5],[9,4],[7,0],[8,0]]
```

output2:
`10`

```c++
long long minCost(vector<vector<int>> &es) {
    int n = es.size() + 1;
    vector<vector<int>> g(n);
    for (auto &e: es) {
        g[e[0]].push_back(e[1]);
        g[e[1]].push_back(e[0]);
    }
    long long ans = 0;
    function<array<long long,2>(int,int)> dfs = [&](int u, int fa) {
        long long cnt = 1;
        for (int v: g[u]) {
            if (v == fa) continue;
            auto res = dfs(v, u);
            cnt += res[0], ans += res[1];
        }
        array<long long,2> ret = {cnt, (cnt + 4) / 5};
        return ret;
    };

    dfs(0, -1);
    return ans;
}
```

### 打开所有灯泡的最小代价

[microsoft oa17](https://www.desiqna.in/7185/microsoft-oa-coding-questions-and-solutions-set-17-2022)

n个灯泡排成一排，其中有一些打开，有一些是关闭的，现在需要将关闭的灯泡用电线直接或间接连接到已打开的灯泡，给定每个灯泡到第一个灯泡到距离，求最短需要多少电线。

```c++
struct DSU {
  public:
    DSU() : _n(0) {}
    explicit DSU(int n) : _n(n), parent_or_size(n, -1) {}

    int merge(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        int x = get(a), y = get(b);
        if (x == y) return x;
        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);
        parent_or_size[x] += parent_or_size[y];
        parent_or_size[y] = x;
        return x;
    }

    bool same(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        return get(a) == get(b);
    }

    int get(int a) {
        assert(0 <= a && a < _n);
        if (parent_or_size[a] < 0) return a;
        return parent_or_size[a] = get(parent_or_size[a]);
    }

    int size(int a) {
        assert(0 <= a && a < _n);
        return -parent_or_size[get(a)];
    }

    std::vector<std::vector<int>> groups() {
        std::vector<int> leader_buf(_n), group_size(_n);
        for (int i = 0; i < _n; i++) {
            leader_buf[i] = get(i);
            group_size[leader_buf[i]]++;
        }
        std::vector<std::vector<int>> result(_n);
        for (int i = 0; i < _n; i++) {
            result[i].reserve(group_size[i]);
        }
        for (int i = 0; i < _n; i++) {
            result[leader_buf[i]].push_back(i);
        }
        result.erase(
            std::remove_if(result.begin(), result.end(),
                           [&](const std::vector<int>& v) { return v.empty(); }),
            result.end());
        return result;
    }

  private:
    int _n;
    // root node: -1 * component size
    // otherwise: parent
    std::vector<int> parent_or_size;
};


int minLength(vector<int> &blubs, vector<int> &d) {
    int n = blubs.size(), cnt1 = 0;
    DSU p(n + 1);
    vector<vector<int>> es;
    for (int i = 0; i < n; ++i) {
        if (blubs[i] == 1) {
            p.merge(i, n);
            cnt1++;
        } else {
            if (i > 0) es.push_back({i, i - 1, d[i] - d[i - 1]});
            if (i < n - 1) es.push_back({i, i + 1, d[i + 1] - d[i]});
        }
    }
    if (cnt1 == 0) return -1;
    int ans = 0;
    sort(es.begin(), es.end(),[&](auto &x, auto &y){
        return x[2] < y[2];
    });

    for(auto &e : es) {
        int x = e[0], y = e[1], c = e[2];
        if (!p.same(x, y)) {
            ans += c;
            p.merge(x, y);
        }
    }
    return ans;
}
```

### 前缀和非负的最少移动次数

[microsoft oa 28](https://www.desiqna.in/9371/microsoft-oa-coding-questions-and-solutions-set-28-2022)

长度为n的数组，每次操作可以选择一个负数移到末尾，求使数组所有前缀和都非负的最少操作次数。

+ 1 <= n <= 1e5
+ -1e9 <= a[i] <= 1e9
+ sum(a[1..n]) >= 0

```c++
int minSwaps(vector<int> &a) {
    priority_queue<int, vector<int>, greater<int>> q;
    long long s = 0;
    int ans = 0;
    for (auto & x : a) {
        s += x;
        if (x < 0) q.push(x);
        if (s < 0) {
            s -= q.top();
            q.pop();
            ans ++;
        } 
    }
    return ans;
}
```

### 能否从b运到e

[microsoft oa62](https://www.desiqna.in/9673/microsoft-oa-coding-questions-and-solutions-set-62-2022)

有n个吊机，位置用数组p给出，每个吊机手臂长度用数组a给出，第i个吊机可以将[p[i]-a[i], p[i]+a[i]] 区间内的任意物体移到区间内任意位置，给你两个位置b和e，能否从b运到e.

+ 1 <= n <= 1e5
+ 0 <= b, e, p[i] <= 1e9
+ 1 <= a[i] <= 1e9

**分析**

构造n个区间，合并有交集区间，判断b,e是否在同一个区间内即可。

```c++
bool canMove(vector<int> &a, vector<int> &p, int b, int e) {
    int n = a.size();
    vector<array<int, 2>> ranges(n), tmp;
    for (int i = 0; i < n; ++i) {
        ranges[i] = {p[i] - a[i], p[i] + a[i]};
    }
    sort(ranges.begin(), ranges.end(), [&](auto &x, auto &y){
        if (x[0] != y[0]) return x[0] < y[0];
        return x[1] < y[1];
    });
    tmp.push_back(ranges[0]);
    for (int i = 1; i < n; ++i) {
        if (ranges[i][0] <= tmp.back()[1]) 
            tmp.back()[1] = max(tmp.back()[1], ranges[i][1]);
        else
            tmp.push_back(ranges[i]);
    }

    auto get = [&](int x) {
        int l = 0, r = tmp.size() - 1, c = -1;
        if (x < tmp[0][0] || x > tmp[r][1]) return -1;
        while (l <= r) {
            int md = (l + r) / 2;
            if (x >= tmp[md][0] && x <= tmp[md][1]) {
                c = md;
                break;
            } else if (x < tmp[md][0]) r = md - 1;
            else l = md + 1;
        }
        return c;
    };

    int x = get(b), y = get(e);

    return (x != -1 && y != -1 && x == y);
}
```

### 相等数组的最长长度

[microsoft oa](https://leetcode.com/discuss/interview-question/2321573/Microsoft-Online-assessment)


输入两个数组a,b, 每次操作可以选择一个数组，将其任意的一个子数组替换为一个整数，该整数位子数组元素之和。
可以操作任意次，求将a,b变为两个相等数组，能获得的最长数组长度，如果无法变为相等，返回-1.

+ 1 <= n, m <= 1e5
+ 1 <= a[i], b[i] <= 1e4

类似题目 [cf 1036d](https://codeforces.com/contest/1036/problem/D)


```c++
int maxLengEqual(vector<long long> &a, vector<long long> &b) {
    int n = a.size(), m = b.size();
    long long s1 = accumulate(a.begin(), a.end(), 0ll);
    long long s2 = accumulate(b.begin(), b.end(), 0ll);
    if (s1 != s2) return -1;
    int ans = 0;
    for (int i = 0, j = 0; i < n && j < m;) {
        if (a[i] == b[j]) {
            ans++, i++, j++;
        } else if(a[i] > b[j]) {
            if (j + 1 < m) b[j + 1] += b[j];
            j++;
        } else {
            if (i + 1 < n) a[i + 1] += a[i];
            i++;
        }
    }
    return ans;
}
```

### 最大收益座位安排

[microsoft oa](https://leetcode.com/discuss/interview-question/2353337/Microsoft-Online-Assessment-Question)

影院有n个座位，第i个座位价值a[i], 有m个团队，第i个团队有b[i]人，每个团队的座位要坐到一块，任意给m个团队安排座位，求能获得的最大收益。

+ 1 <= n <= 500
+ 1 <= m <= 13
+ 1 <= a[i] <= 1e9
+ 1 <= b[i] <= n
+ b[1] + b[2] + .. + b[m] <= n

示例输入:
```
6 2
1 7 8 2 3 9
2 1
```

输出
```
24
```

**状态压缩dp**

```c++
long long maxProfit(vector<int> &a, vector<int> &b) {
    int n = a.size(), m = b.size();
    vector<long long> p(n + 1);
    for (int i = 0; i < n; ++i) {
        p[i + 1] = p[i] + a[i];
    }
    vector dp(n + 1, vector<long long>((1 << m), -1));
    long long inf = 1e18, ans = 0;

    function<long long(int, int)> dfs = [&](int i, int mask) {
        if (i >= n) return 0;
        if (dp[i][mask] >= 0) return dp[i][mask];
        dp[i][mask] = 0;
        for (int k = 0; k < m; ++k) {
            if (!(mask & (1 << k))) {
                dp[i][mask] = max(dp[i][mask], p[i + b[k]] - p[i] + dfs(i + b[k], mask | (1 << k)));
            }
        }
        return dp[i][mask] = max(dp[i][mask], dfs(i + 1, mask));
    };

    return dfs(0, 0);;
}
```

code2 ,未验证

```c++
long long maxProfit1(vector<int> &a, vector<int> &b) {
    int n = a.size(), m = b.size();
    vector<long long> p(n + 1);
    for (int i = 0; i < n; ++i) {
        p[i + 1] = p[i] + a[i];
    }
    vector dp(n + 1, vector<long long>((1 << m), -1));
    long long inf = 1e18, ans = 0;

    function<long long(int, int)> dfs = [&](int i, int mask) -> long long {
        if (i >= n) return 0;
        if (dp[i][mask] >= 0) return dp[i][mask];
        dp[i][mask] = 0;
        for (int k = 0; k < m; ++k) {
            if (!(mask & (1 << k))) {
                dp[i][mask] = max(dp[i][mask], p[i + b[k]] - p[i] + dfs(i + b[k], mask | (1 << k)));
            }
        }
        return dp[i][mask] = max(dp[i][mask], dfs(i + 1, mask));
    };

    return dfs(0, 0);;
}
```

### 所有病人得到预约

[microsoft oa](https://leetcode.com/discuss/interview-question/2848739/Microsoft-OA-or-Doctor-appointment-slots)

n个病人，每个病人有两个喜欢的时间a[i]和b[i]，可以在这两个时间的任意一个去看医生，医生有m个时间槽，编号1-m，有没有一种安排方式，所有病人都在自己喜欢的时间去看医生，且医生在每个时间槽最多只看一位病人。

+ 1 <= n <= 1e6
+ 1 <= m <= 2e6
+ 1 <= a[i], b[i] <= m
+ a[i] != b[i] for i = 1,..,n


**分析**

并查集，连接出现在同一病人喜欢的时间顶点，同一个连通图中出现的患者数量要不超过连通图中的时间节点数量。


```c++
bool isGoodArrange(vector<int> &a, vector<int> &b, int m) {
    int n = a.size();
    DSU d(m);

    for (int i = 0; i < n; ++i) {
        d.merge(a[i], b[i]);
    }
    vector<int> freq(m);
    for (int i = 0; i < n; ++i) {
        freq[d.get(a[i])]++;
    }

    for (int i = 0; i < n; ++i) {
        if (d.size(a[i]) < freq[d.get(a[i])]) {
            return false;
        }
    }
    return true;
}

```



## appleoa

### 树中节点统计

[apple oa](https://www.desiqna.in/6783/apple-oa-sde1-coding-questions-and-solutions-2022-set-4)

给定n个节点的树，根结点是1，每个节点有个值，用数组a给出，对每个节点，统计如下两个值的和：
1.所有祖先节点中小于该节点值的和
2.所有祖先节点中大于该节点值的节点个数乘以当前节点的值

+ 1 <= n <= 1e5

```c++
// 0 based

template <typename T>
struct Fenwick {
    int n;
    std::vector<T> a;
    Fenwick(int n) : n(n), a(n) {}
    void add(int x, T v) { // x: 1-based
        for (int i = x; i <= n; i += i & -i) {
            a[i - 1] += v;
        }
    }
    T qry(int x) {
        T ans = 0;
        for (int i = x; i > 0; i -= i & -i) {
            ans += a[i - 1];
        }
        return ans;
    }
    T qry(int l, int r) {  //sum[l,..r] l,r: 1-based
        if (l > r) return 0;
        return qry(r) - qry(l - 1);
    }
};

vector<long long> getValue(vector<int> &a, vector<vector<int>> &es) {
    int n = a.size();
    vector<long long> ans(n);

    vector<vector<int>> g(n);
    for(auto&e : es) {
        g[e[0]].push_back(e[1]);
        g[e[1]].push_back(e[0]);
    }

    Fenwick<long long> t1(n + 1), t2(n + 1);

    auto v = a;
    sort(v.begin(), v.end());
    v.erase(unique(begin(v), end(v)), end(v));

    auto get = [&](long long x) {
        return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
    };

    function<void(int, int)> dfs = [&](int u, int fa) {
        int t = get(a[u]);
        long long x = t1.qry(1, t - 1), y = t2.qry(t + 1, n) * a[u];
        ans[u] = x + y;
        t1.add(t, a[u]);
        t2.add(t, 1);
        for (auto &v : g[u]) {
            if (v == fa) continue;
            dfs(v, u);
        }
        t1.add(t, -a[u]);
        t2.add(t, -1);
    };

    dfs(0, -1);

    return ans;
}
```

### 连通分量统计

n个点m条边的无向图，每个顶点有一个炸弹，炸弹会按照城市1到n的顺序依次爆炸，每次爆炸会销毁当前顶点以及所连接的边，对于每次爆炸，求爆炸后图中连通分量的数量。

+ 1 <= n <= 2e5
+ 0 <= m <= min(2e5,n(n-1)/2)

示例

input:
```
n = 6, m = 7
edges = [[1,2],[1,4],[1,5],[2,4],[2,3],[3,5],[3,6]]
```
output:
`1 2 3 2 1 0`

<br />
![](/images/posts/leetcode/google_3.png)
<br />


```c++
struct DSU {
  public:
    DSU() : _n(0) {}
    explicit DSU(int n) : _n(n), parent_or_size(n, -1) {}

    int merge(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        int x = get(a), y = get(b);
        if (x == y) return x;
        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);
        parent_or_size[x] += parent_or_size[y];
        parent_or_size[y] = x;
        return x;
    }

    bool same(int a, int b) {
        assert(0 <= a && a < _n);
        assert(0 <= b && b < _n);
        return get(a) == get(b);
    }

    int get(int a) {
        assert(0 <= a && a < _n);
        if (parent_or_size[a] < 0) return a;
        return parent_or_size[a] = get(parent_or_size[a]);
    }

    int size(int a) {
        assert(0 <= a && a < _n);
        return -parent_or_size[get(a)];
    }

    std::vector<std::vector<int>> groups() {
        std::vector<int> leader_buf(_n), group_size(_n);
        for (int i = 0; i < _n; i++) {
            leader_buf[i] = get(i);
            group_size[leader_buf[i]]++;
        }
        std::vector<std::vector<int>> result(_n);
        for (int i = 0; i < _n; i++) {
            result[i].reserve(group_size[i]);
        }
        for (int i = 0; i < _n; i++) {
            result[leader_buf[i]].push_back(i);
        }
        result.erase(
            std::remove_if(result.begin(), result.end(),
                           [&](const std::vector<int>& v) { return v.empty(); }),
            result.end());
        return result;
    }

  private:
    int _n;
    // root node: -1 * component size
    // otherwise: parent
    std::vector<int> parent_or_size;
};


vector<int> getComponent(int n, vector<vector<int>>& es) {
    vector<vector<int>> g(n);
    for (auto &e: es) {
        g[e[0]].push_back(e[1]);
        g[e[1]].push_back(e[0]);
    }

    vector<int> ans(n), vis(n);

    DSU d(n);

    int t = 0;

    for (int i = n - 1; i > 0; --i) {
        t++;
        for (auto &v : g[i]) {
            if (vis[v] && !d.same(i, v)) {
                t--;
                d.merge(i, v);
            }
        }
        ans[i - 1] = t, vis[i] = 1;
    }
    return ans;
}
```

### 树的切分方案数

n个点的树，树的值定义为树中所有节点的按位与之和，求满足下述条件的树的切分方案数目：

+ 删除树中一条边，使得形成的两棵树的值相等。
+ 2 <= n <= 1e5
+ 1 <= a[i] <= 2^(31)-1

**分析**

设以节点0为根，维护如下两个数组:

+ cnt[i]:以i为根的子树包含的节点个数
+ s[i][j]:以i为根的子树包含的节点中第j位为1的个数

删除某条边e时，设其顶点为u,v，cnt[u]>cnt[v], 则可以求出以v为根节点的值，和剩余子树的值。

```c++
int treeSplit(vector<int> &a, vector<vector<int>> &es) {
    int n = a.size(), ans = 0;
    vector<vector<int>> g(n), s(n, vector<int>(32));

    for (auto &e : es) {
        g[e[0]].push_back(e[1]);
        g[e[1]].push_back(e[0]);
    }

    vector<int> cnt(n);

    function<void(int, int)> dfs = [&](int u, int fa) {
        cnt[u] = 1;
        for (int i = 0; i < 32; ++i) if (a[u] & (1 << i))
            s[u][i] = 1;

        for (auto &v : g[u]) {
            if (v == fa) continue;
            dfs(v, u);
            cnt[u] += cnt[v];
            for (int i = 0; i < 32; ++i) 
                s[u][i] += s[v][i];
        }
    };

    auto get = [&](vector<int> &p, int k) {
        int x = 0;
        for (int i = 0; i < 32; ++i) if (p[i] == k)
            x = x | (1 << i);
        return x;
    };

    dfs(0, -1);

    for (auto &e : es) {
        int u = e[0], v = e[1];
        if (cnt[u] < cnt[v]) swap(u, v);
        vector<int> c(32);
        for (int i = 0; i < 32; ++i) 
            c[i] = s[0][i] - s[v][i];
        if (get(c, cnt[0] - cnt[v]) == get(s[v], cnt[v])) ans++;
    }
    return ans;
}
```

### 树上询问

n个点的树(1-n)，给个节点有一个值，1是根节点，q个询问，每个询问给定 (v, k) ,回答以v为根节点的子树中第k大数是多少？

+ 2 <= n <= 1e5
+ 0 <= a[i] <= 1e9
+ 1 <= q <= 1e5
+ 1 <= ki <= min(20, vi子树节点的数目)

input1:
```
n=5,q=2
es=[[1,4],[2,1],[2,5],[3,2]]
qs=[[1,2],[2,1]]
```

output:
```
4 5
```

```c++
vector<int> treeQuerys(vector<int> &a, vector<vector<int>> &es, vector<vector<int>> &qs) {
    int n = a.size(), m = qs.size();
    vector<vector<int>> g(n), s(n);
    vector<priority_queue<int, vector<int>, greater<int>>> p(n);

    for(auto& e: es) {
        g[e[0]].push_back(e[1]);
        g[e[1]].push_back(e[0]);
    }

    function<void(int, int)> dfs = [&](int u, int fa) {
        p[u].push(a[u]);
        for (auto &v : g[u]) {
            if (v == fa) continue;
            dfs(v, u);
            auto q = p[v];
            while(!q.empty()) {
                p[u].push(q.top()); 
                q.pop();
                if(p[u].size() > 20) p[u].pop();
            }
        }
    };

    dfs(0, -1);

    for (int i = 0; i < n; ++i) {
        while(p[i].size()) {
            s[i].push_back(p[i].top());
            p[i].pop();
        }
        sort(rall(s[i]));
    }

    vector<int> ans(m);
    for (int i = 0; i < m; ++i) {
        int v = qs[i][0], k = qs[i][1];
        ans[i] = s[v][k - 1];
    }
    return ans;
}
```

### 前缀得分

数组a的前缀子数组a[1..k] 的得分定义为：

+ 对于 1 <= i <= k, 按顺序将当前前缀数组元素的最大值加到a[i]中
+ a[k]的得分是 a[1..k]的最终元素的和

对于 k = 1,..n，计算a[i] 的得分，模 1e9+7

+ 1 <= n <= 2e5
+ 1 <= arr[i] <= 1e6

示例：

```
a = [1, 2, 3], ans = [0, 0, 0]

k = 1 时：
a[1..1] = [1]
mx(a[1..1]) = 1

new_array = [2]
ans[0] = sum(new_array) = 2

k=2时：
a[1..2] = [1,2]
mx(a[1..2]) = 2

new_array = [1 + 2, 2] -> [3, 2] -> [3, 2 + 3] -> [3, 5]
ans[1] = sum(new_array) = 8

k=3时：
a[1..3] = [1,2,3]
mx(a[1..3]) = 3

new_array = [4,2,3] -> [4, 6, 3] -> [4, 6, 9]
ans[2] = sum(new_array) = 19
```

**分析**

设s为a的前缀和数组，对于 i = k 时， mx = max(a[1..k]) 最终数组如下

a_new[1] = a[1] + mx = s[1] + mx
a_new[2] = a_new[1] + a[2] = a[1] + a[2] + mx = s[2] + mx
...
a_new[k] = a_new[k - 1] + a[k] = s[k] + mx

```c++
vector<int> arrayScore(vector<int> &a) {
    int n = a.size(), mod = 1e9 + 7;
    vector<long long> p(n + 1);
    for (int i = 0; i < n; ++i) {
        p[i + 1] = p[i] + a[i];
    }
    vector<int> c(n);
    long long s = 0, mx = 0;
    for (int i = 0; i < n; ++i) {
        mx = max(mx, (long long)a[i]);
        s = (s + p[i + 1]) % mod;
        c[i] = (s + (i + 1ll) * mx) % mod;
    }
    return c;
}
```

### 唯一的子序列

正整数数组a, 求其有多少个非空子序列，满足子序列中的没有重复元素。
返回答案模 1e9+7

+ 1 <= n <= 1e5
+ 1 <= a[i] <= 1e6

**动态规划**

非空子序列不是子数组，答案与数组元素顺序无关，所以可以先对数组进行排序。

+ dp[i][0]表示前i个元素，且不包含第i个元素能组成的非空子序列数目
+ dp[i][1]表示前i个元素，且包含第i个元素能组成的非空子序列数目

mp[a[i]] 维护a[i]在排序后数组第一次出现的下标

则：

```
dp[i + 1][0] = dp[i][0] + dp[i][1]
dp[i + 1][1] = dp[mp[a[i]]][0] + dp[mp[a[i]]][1] + 1
```

```c++
int countUniqueSeq(vector<int> &a) {
    int n = a.size(), mod = 1e9 + 7;
    sort(a.begin(), a.end());
    vector dp(n + 1, vector<int>(2));
    map<int, int> mp;
    for (int i = 0; i < n; ++i) {
        if (!mp.count(a[i])) mp[a[i]] = i;
        dp[i + 1][0] = (dp[i][0] + dp[i][1]) % mod;
        dp[i + 1][1] = (dp[mp[a[i]]][0] + dp[mp[a[i]]][1] + 1) % mod;
        
    }
    return (dp[n][0] + dp[n][1]) % mod;
}
```

### 最小区间集合

给定n个闭区间，求最小的集合大小，使得每个区间都至少有两个数出现在集合中。

+ 1 <= n <= 1e5
+ 0 <= a[i][0] < a[i][1] < 1e9

**分析**

经典贪心

```c++
int miniIntervals(vector<vector<int>> &a) {
    int n = a.size(), ans = 0, last = -1, pre = -1;
    sort(a.begin(), a.end(), [&](auto &x, auto &y){
        if (x[1] == y[1]) return x[0] > y[0];
        return x[1] < y[1];
    });
    for (int i = 0; i < n; ++i) {
        if (pre >= a[i][0]) continue;
        else if (last >= a[i][0]) {
            ans++, pre = last, last = a[i][1];
        } else {
            ans += 2, last = a[i][1], pre = last - 1;
        }
    }
    return ans;
}
```

### 最小数组长度

redhat oa

长度为n的数组，每次可以选择两个相邻的正整数a[i]和a[i+1]，将两个正整数替换为 (a[i]%a[i+1]) 或者 a[i+1]%a[i], 数组的长度减1，求操作后能得到的最小数组长度。

+ 1 <= n <= 1e5
+ 1 <= a[i] <= 1e9

示例：
```
a = [1,1,3] output: 1
a = [2,2,2,2] output: 2
```

```c++
int getMinimumLength(vector<int> &a) {

}
```

### 移到n的最小代价

indeep oa

长度为n的数组，a[i]:表示第i位置有n个人，每一次操作可以将位置i的一个人移到位置j处，当且仅当 a[i,..j-1] >= 1 成立。每次操作代价为k，求将所有人移到位置n所消耗的最小代价。

+ 1 <= n <= 1e5
+ 0 <= a[i] <= 1e4
+ 1 <= k <= 100

示例：
```
a=[2,0,0], k=5,
output: 15
```

```c++
long long minShiftCost(vector<int> &a, int k) {

}
```

### 任意排列数组的最小绝对和

[trilogy oa](https://www.desiqna.in/11238/aesthetic-permutation-triology-codenation-dynamic-programming)

出入数组n和整数k，定义数组绝对和为 abs(a[i]-a[i+k]) 对于i=1,..n-k, 假设可以将数组a任意排列，求可能得到的最小绝对和。

+ 2 <= n <= 3e5
+ 1 <= k <= min(5000, n-1)
+ -1e9 <= a[i] <= 1e9

```c++
long long minSumPerm(vector<int> &a, int k) {
    int n = a.size();
    vector dp(k + 1, vector<long long>(k + 1));
    vector<long long> diff(n);
    long long p1 = n / k, p2 = p1 + 1, n1 = 0, n2 = 0;

    for (int i = 1; i <= k; ++i) {
        long long t = (n - i) / k + 1;
        if (t == p1) n1++;
        if (t == p2) n2++;
    }

    sort(a.begin(), a.end());

    for (int i = 1; i < n; ++i) {
        diff[i] = diff[i - 1] + abs(a[i] - a[i - 1]);
    }

    auto get = [&](int x, int y) {
        return abs(diff[y - 1] - diff[x - 1]);
    };

    for (int i = 1; i <= n1; ++i) {
        int x = i * p1, y = x - p1 + 1;
        dp[i][0] = dp[i - 1][0] + get(y, x);
    }

    for (int i = 1; i <= n2; ++i) {
        int x = i * p2, y = x - p2 + 1;
        dp[0][i] = dp[0][i - 1] + get(y, x);
    }

    for (int i = 1; i <= n1; ++i) {
        for (int j = 1; j <= n2; ++j) {
            long long s = i * p1 + j * p2;
            dp[i][j] = min(dp[i][j - 1] + get(s - p2 + 1, s), dp[i - 1][j] + get(s - p1 + 1, s));
        }
    }
    return dp[n1][n2];
}
```